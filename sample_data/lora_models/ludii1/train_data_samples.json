[
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n2x6 board. Four counters in each hole.  A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a clockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. When the final counter falls into an occupied hole, these are picked up and sowing continues. When the final counter of a sowing lands in an empty hole in the player's own row, the contents of the hole in the opponent's row opposite it are captured. If the opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row.\n         \n\n### Response:\n",
    "completion": "(define \"PiecesOwnedBy\" (+ (count Cell at:(handSite #1)) (count in:(sites #1)))) (define \"Columns\" 6) (game \"Foji\" (players 2) (equipment { (mancalaBoard 2 \"Columns\" store:None (track \"Track\" \"5,W,N,E\" loop:True)) (piece \"Seed\" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) (play (if (is Proposed \"End\") (or (move Vote \"End\") (move Vote \"No\")) (or (if (is Cycle) (move Propose \"End\")) (if (\"SameTurn\") (move Select (from \"LastHoleSowed\") (then (sow apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover)) (if (is Occupied (\"OppositePit\" (to))) (fromTo (from (\"OppositePit\" (to))) (to (handSite Mover)) count:(count at:(\"OppositePit\" (to))))))) includeSelf:False))) (do (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover)) (if (is Occupied (\"OppositePit\" (to))) (fromTo (from (\"OppositePit\" (to))) (to (handSite Mover)) count:(count at:(\"OppositePit\" (to))))))) includeSelf:False))) ifAfterwards:(if (is Mover P1) (< 0 (count in:(sites P2))) (< 0 (count in:(sites P1))))))))) (end (\"MancalaByScoreWhen\" (or (no Moves Mover) (is Decided \"End\"))))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "2x6 board. Four counters in each hole.  A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a clockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. When the final counter falls into an occupied hole, these are picked up and sowing continues. When the final counter of a sowing lands in an empty hole in the player's own row, the contents of the hole in the opponent's row opposite it are captured. If the opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row.\n         "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nChecks if a piece #1 owned by #2 is at a site #3.\n\n### Response:\n",
    "completion": "(define \"IsPieceAt\" (= (what at:#3 #4) (id #1 #2)))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Checks if a piece #1 owned by #2 is at a site #3."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction, beginning from any hole in the player's row. When the final counter lands in a hole in the opponent's row containing three (four counting the last counter dropped into it), these are taken. In addition, the contents of any hole in the opponent's row which a player causes to contain four counters are captured. When the final counter lands in an empty hole, the turn ends. When the final counter lands in an occupied hole containing a number of counters other than three, the counters are picked up and sowing continues. If sowing reaches the original hole from which the sowing began, this hole is skipped over. A player must play so that the opponent has counters with which to play, if possible. \n\n### Response:\n",
    "completion": "(define \"PiecesOwnedBy\" (+ (count Cell at:(handSite #1)) (count in:(sites #1)))) (game \"Wouri\" (players 2) (equipment { (mancalaBoard 2 6 store:None (track \"Track\" \"0,E,N,W\" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece \"Seed\" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (if (\"SameTurn\") \"LastHoleSowed\" (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (and (is In (to) (sites Next)) (= (count at:(to)) 4)) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)) (then (forEach Site (if (is Mover P1) (sites P2) (sites P1)) (if (= (count at:(site)) 4) (fromTo (from (site)) (to (handSite Mover)) count:(count at:(site))))))) (if (< 1 (count at:(to))) (moveAgain))) includeSelf:False))) ifAfterwards:(< 0 (count in:(if (is Mover P1) (sites P2) (sites P1)))))) (end (\"MancalaByScoreWhen\" (no Moves Mover)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction, beginning from any hole in the player's row. When the final counter lands in a hole in the opponent's row containing three (four counting the last counter dropped into it), these are taken. In addition, the contents of any hole in the opponent's row which a player causes to contain four counters are captured. When the final counter lands in an empty hole, the turn ends. When the final counter lands in an occupied hole containing a number of counters other than three, the counters are picked up and sowing continues. If sowing reaches the original hole from which the sowing began, this hole is skipped over. A player must play so that the opponent has counters with which to play, if possible. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nThe version of the game played with 3 players. -> The version of the game played with 4 players.\n\n### Input:\n(game \"Ciri Amber\" (players 3) (equipment { (board (complete (regular Star 7)) use:Edge) (piece \"Marker\" Neutral)}) (rules (start { (set Neutral Edge (sites Board Edge)) (set Cost 1 Edge at:0) (set Cost 2 Edge at:1) (set Cost 3 Edge at:2) (set Cost 1 Edge at:3) (set Cost 2 Edge at:4) (set Cost 3 Edge at:5) (set Cost 1 Edge at:6) (set Cost 2 Edge at:7) (set Cost 3 Edge at:8) (set Cost 3 Edge at:9) (set Cost 1 Edge at:10) (set Cost 2 Edge at:11) (set Cost 3 Edge at:12) (set Cost 1 Edge at:13) (set Cost 2 Edge at:14) (set Cost 3 Edge at:15) (set Cost 1 Edge at:16) (set Cost 2 Edge at:17) (set Cost 3 Edge at:18) (set Cost 3 Edge at:19) (set Cost 1 Edge at:20)}) (play (move Remove (sites Occupied by:Neutral) (then (addScore Mover (cost Edge at:(last To)))))) (end (if (is RegularGraph Neutral) (byScore)))))\n\n### Response:\n",
    "completion": "(game \"Ciri Amber\" (players 4) (equipment { (board (complete (regular Star 7)) use:Edge) (piece \"Marker\" Neutral)}) (rules (start { (set Neutral Edge (sites Board Edge)) (set Cost 1 Edge at:0) (set Cost 2 Edge at:1) (set Cost 3 Edge at:2) (set Cost 1 Edge at:3) (set Cost 2 Edge at:4) (set Cost 3 Edge at:5) (set Cost 1 Edge at:6) (set Cost 2 Edge at:7) (set Cost 3 Edge at:8) (set Cost 3 Edge at:9) (set Cost 1 Edge at:10) (set Cost 2 Edge at:11) (set Cost 3 Edge at:12) (set Cost 1 Edge at:13) (set Cost 2 Edge at:14) (set Cost 3 Edge at:15) (set Cost 1 Edge at:16) (set Cost 2 Edge at:17) (set Cost 3 Edge at:18) (set Cost 3 Edge at:19) (set Cost 1 Edge at:20)}) (play (move Remove (sites Occupied by:Neutral) (then (addScore Mover (cost Edge at:(last To)))))) (end (if (is RegularGraph Neutral) (byScore)))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nThe version of the game played with 3 players. -> The version of the game played with 4 players.",
    "_var_input": "(game \"Ciri Amber\" (players 3) (equipment { (board (complete (regular Star 7)) use:Edge) (piece \"Marker\" Neutral)}) (rules (start { (set Neutral Edge (sites Board Edge)) (set Cost 1 Edge at:0) (set Cost 2 Edge at:1) (set Cost 3 Edge at:2) (set Cost 1 Edge at:3) (set Cost 2 Edge at:4) (set Cost 3 Edge at:5) (set Cost 1 Edge at:6) (set Cost 2 Edge at:7) (set Cost 3 Edge at:8) (set Cost 3 Edge at:9) (set Cost 1 Edge at:10) (set Cost 2 Edge at:11) (set Cost 3 Edge at:12) (set Cost 1 Edge at:13) (set Cost 2 Edge at:14) (set Cost 3 Edge at:15) (set Cost 1 Edge at:16) (set Cost 2 Edge at:17) (set Cost 3 Edge at:18) (set Cost 3 Edge at:19) (set Cost 1 Edge at:20)}) (play (move Remove (sites Occupied by:Neutral) (then (addScore Mover (cost Edge at:(last To)))))) (end (if (is RegularGraph Neutral) (byScore)))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayed on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them if they are adjacent. Capturing must happen if it is possible, multiple captures are allowed, and can happen in a forward or backward direction. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. A piece may become a king in the midst of a sequence of captures, and then capture as a king in the same turn. Kings may capture over any distance, leaping over all opponent's pieces in a line. The goal is to capture all of the opponent's pieces.\n         \n\n### Response:\n",
    "completion": "(define \"JumpToPromotionZone\" (is In (last To) (sites Next))) (define \"IsUnpromoted\" (\"IsPieceAt\" \"Counter\" Mover (last To))) (define \"HopCounter\" (move Hop (from #1) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (\"IsEnemyAt\" (between))) (apply (remove (between)))) (to if:(is Empty (to))) #2)) (game \"Shashki\" (\"TwoPlayersNorthSouth\") (\"DraughtsEquipment\" (square 8)) (rules (\"BlackCellsSetup\" 3) (play (if \"SameTurn\" (if \"IsUnpromoted\" (\"HopCounter\" (last To) (then (if \"JumpToPromotionZone\" (and (promote (last To) (piece \"DoubleCounter\") Mover) (\"ReplayIfCanMove\" (\"HopDiagonalSequenceCaptureAgain\" before:(count Rows) after:(count Rows)))) (\"ReplayIfCanMove\" (\"HopCounter\" (last To)))))) (\"HopDiagonalSequenceCaptureAgain\" before:(count Rows) after:(count Rows))) (priority { (or (forEach Piece \"Counter\" (\"HopCounter\" (from) (then (if \"JumpToPromotionZone\" (and (promote (last To) (piece \"DoubleCounter\") Mover) (\"ReplayIfCanMove\" (\"HopDiagonalSequenceCaptureAgain\" before:(count Rows) after:(count Rows)))) (\"ReplayIfCanMove\" (\"HopCounter\" (last To))))))) (forEach Piece \"DoubleCounter\" (\"HopDiagonalSequenceCapture\" before:(count Rows) after:(count Rows)))) (or (forEach Piece \"Counter\" (\"StepToEmpty\" (directions {FR FL})) (then (\"PromoteIfReach\" (sites Next) \"DoubleCounter\"))) (forEach Piece \"DoubleCounter\" (move Slide Diagonal)))}))) (end (\"CaptureAll\" Next))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them if they are adjacent. Capturing must happen if it is possible, multiple captures are allowed, and can happen in a forward or backward direction. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. A piece may become a king in the midst of a sequence of captures, and then capture as a king in the same turn. Kings may capture over any distance, leaping over all opponent's pieces in a line. The goal is to capture all of the opponent's pieces.\n         "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n10x10 board. The black player starts by removing one black piece either from one of the central four spaces of the board or from one of the four corners. The white player then must remove a white piece that is orthogonally adjacent to the empty space. Play proceeds by orthogonally jumping an opposing piece and capturing it. All moves must be capturing moves. Multiple captures can be made only by continuing in the same direction. The first player unable to move loses. The game is played on a 10x10 board.\n\n### Response:\n",
    "completion": "(define \"HopSequence\" (\"HopCapture\" (from #1) #2 (then (\"ReplayIfCanMove\" (\"HopCapture\" (from (last To)) SameDirection))))) (game \"Konane\" (players 2) (equipment { (board (square 10)) (piece \"Marker\" Each)}) (rules (start { (place \"Marker1\" (sites Phase 1)) (place \"Marker2\" (sites Phase 0))}) phases:{ (phase \"OpeningP1\" P1 (play (move Remove (intersection (union (sites Corners) (sites Centre)) (sites Phase 1)))) (nextPhase Mover \"Movement\")) (phase \"OpeningP2\" P2 (play (move Remove (sites Around (last To) Own))) (nextPhase Mover \"Movement\")) (phase \"Movement\" (play (if \"SameTurn\" (or (\"HopSequence\" (last To) SameDirection) (move Pass)) (forEach Piece \"Marker\" (\"HopSequence\" (from) Orthogonal)))))} (end (\"NoMoves\" Loss))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "10x10 board. The black player starts by removing one black piece either from one of the central four spaces of the board or from one of the four corners. The white player then must remove a white piece that is orthogonally adjacent to the empty space. Play proceeds by orthogonally jumping an opposing piece and capturing it. All moves must be capturing moves. Multiple captures can be made only by continuing in the same direction. The first player unable to move loses. The game is played on a 10x10 board."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nThe game involves 2 players. -> The game involves 3 players.\nThe track is composed of 20 spaces -> The track is composed of 25 spaces\n\n### Input:\n(define \"SetHyenaPlayer\" (and (add (piece \"Hyena\") (to 0) stack:True) (set Var (id Mover)))) (define \"HyenaPlayer\" (var)) (define \"SiteHyenaToMove\" (\"SiteToMoveOnTrack\" from:(where \"Hyena\" Shared) (* 2 (\"ThrowValue\")))) (define \"SiteToMove\" (if (= (from) (handSite Mover)) (\"SiteToMoveOnTrack\" from:0 (- (\"ThrowValue\") 1)) (\"SiteToMoveOnTrack\" from:(from) (\"ThrowValue\")))) (define \"SiteToMoveOnTrack\" (\"NextSiteOnTrack\" #2 #1)) (define \"ThrowValue\" (mapEntry \"Throw\" (count Pips))) (game \"Nama\" (players 2) (equipment { (board (rectangle 20 1) (track \"Track\" {0..19} directed:True)) (hand Each) (hand Shared) (piece \"Marker\" Each (if (\"IsOffBoard\" (\"SiteToMove\")) (move Remove (from) level:(level) (then (if (\"IsOffBoard\" (where \"Hyena\" Shared)) (\"SetHyenaPlayer\")))) (move (from (from) level:(level)) (to (\"SiteToMove\")) stack:True))) (piece \"Hyena\" Shared) (\"StickDice\" 4) (map \"Throw\" {(pair 0 0) (pair 1 0) (pair 2 2) (pair 3 0) (pair 4 20)})}) (rules (start (place \"Marker\" \"Hand\")) (play (\"RollMove\" (if (< 0 (\"ThrowValue\")) (if (= (\"HyenaPlayer\") (id Mover)) (if (\"IsOffBoard\" (\"SiteHyenaToMove\")) (move Remove (where \"Hyena\" Shared) (then (forEach Site (sites Board) (if (is Occupied (site)) (remove (site) count:(size Stack at:(site))))))) (move (from (where \"Hyena\" Shared)) (to (\"SiteHyenaToMove\")) (then (forEach Value min:1 max:(- (* 2 (\"ThrowValue\")) 1) (if (is Occupied (\"SiteToMoveOnTrack\" from:(last From) (value))) (remove (\"SiteToMoveOnTrack\" from:(last From) (value)) count:(size Stack at:(\"SiteToMoveOnTrack\" from:(last From) (value))))))))) (or (forEach Piece) (forEach Piece container:(mover))))))) (end { (forEach Player if:(and { (> (\"HyenaPlayer\") 0) (!= (player) (\"HyenaPlayer\")) (\"IsOffBoard\" (where \"Hyena\" Shared))}) (result Player Loss)) (if (and (= (id Mover) (\"HyenaPlayer\")) (\"IsOffBoard\" (where \"Hyena\" Shared))) (result Mover Win)) (forEach Player if:(and (!= (player) (\"HyenaPlayer\")) (no Pieces of:(player))) (result Player Loss))})))\n\n### Response:\n",
    "completion": "(define \"SetHyenaPlayer\" (and (add (piece \"Hyena\") (to 0) stack:True) (set Var (id Mover)))) (define \"HyenaPlayer\" (var)) (define \"SiteHyenaToMove\" (\"SiteToMoveOnTrack\" from:(where \"Hyena\" Shared) (* 2 (\"ThrowValue\")))) (define \"SiteToMove\" (if (= (from) (handSite Mover)) (\"SiteToMoveOnTrack\" from:0 (- (\"ThrowValue\") 1)) (\"SiteToMoveOnTrack\" from:(from) (\"ThrowValue\")))) (define \"SiteToMoveOnTrack\" (\"NextSiteOnTrack\" #2 #1)) (define \"ThrowValue\" (mapEntry \"Throw\" (count Pips))) (game \"Nama\" (players 3) (equipment { (board (rectangle 25 1) (track \"Track\" {0..24} directed:True)) (hand Each) (hand Shared) (piece \"Marker\" Each (if (\"IsOffBoard\" (\"SiteToMove\")) (move Remove (from) level:(level) (then (if (\"IsOffBoard\" (where \"Hyena\" Shared)) (\"SetHyenaPlayer\")))) (move (from (from) level:(level)) (to (\"SiteToMove\")) stack:True))) (piece \"Hyena\" Shared) (\"StickDice\" 4) (map \"Throw\" {(pair 0 0) (pair 1 0) (pair 2 2) (pair 3 0) (pair 4 20)})}) (rules (start (place \"Marker\" \"Hand\")) (play (\"RollMove\" (if (< 0 (\"ThrowValue\")) (if (= (\"HyenaPlayer\") (id Mover)) (if (\"IsOffBoard\" (\"SiteHyenaToMove\")) (move Remove (where \"Hyena\" Shared) (then (forEach Site (sites Board) (if (is Occupied (site)) (remove (site) count:(size Stack at:(site))))))) (move (from (where \"Hyena\" Shared)) (to (\"SiteHyenaToMove\")) (then (forEach Value min:1 max:(- (* 2 (\"ThrowValue\")) 1) (if (is Occupied (\"SiteToMoveOnTrack\" from:(last From) (value))) (remove (\"SiteToMoveOnTrack\" from:(last From) (value)) count:(size Stack at:(\"SiteToMoveOnTrack\" from:(last From) (value))))))))) (or (forEach Piece) (forEach Piece container:(mover))))))) (end { (forEach Player if:(and { (> (\"HyenaPlayer\") 0) (!= (player) (\"HyenaPlayer\")) (\"IsOffBoard\" (where \"Hyena\" Shared))}) (result Player Loss)) (if (and (= (id Mover) (\"HyenaPlayer\")) (\"IsOffBoard\" (where \"Hyena\" Shared))) (result Mover Win)) (forEach Player if:(and (!= (player) (\"HyenaPlayer\")) (no Pieces of:(player))) (result Player Loss))})))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nThe game involves 2 players. -> The game involves 3 players.\nThe track is composed of 20 spaces -> The track is composed of 25 spaces",
    "_var_input": "(define \"SetHyenaPlayer\" (and (add (piece \"Hyena\") (to 0) stack:True) (set Var (id Mover)))) (define \"HyenaPlayer\" (var)) (define \"SiteHyenaToMove\" (\"SiteToMoveOnTrack\" from:(where \"Hyena\" Shared) (* 2 (\"ThrowValue\")))) (define \"SiteToMove\" (if (= (from) (handSite Mover)) (\"SiteToMoveOnTrack\" from:0 (- (\"ThrowValue\") 1)) (\"SiteToMoveOnTrack\" from:(from) (\"ThrowValue\")))) (define \"SiteToMoveOnTrack\" (\"NextSiteOnTrack\" #2 #1)) (define \"ThrowValue\" (mapEntry \"Throw\" (count Pips))) (game \"Nama\" (players 2) (equipment { (board (rectangle 20 1) (track \"Track\" {0..19} directed:True)) (hand Each) (hand Shared) (piece \"Marker\" Each (if (\"IsOffBoard\" (\"SiteToMove\")) (move Remove (from) level:(level) (then (if (\"IsOffBoard\" (where \"Hyena\" Shared)) (\"SetHyenaPlayer\")))) (move (from (from) level:(level)) (to (\"SiteToMove\")) stack:True))) (piece \"Hyena\" Shared) (\"StickDice\" 4) (map \"Throw\" {(pair 0 0) (pair 1 0) (pair 2 2) (pair 3 0) (pair 4 20)})}) (rules (start (place \"Marker\" \"Hand\")) (play (\"RollMove\" (if (< 0 (\"ThrowValue\")) (if (= (\"HyenaPlayer\") (id Mover)) (if (\"IsOffBoard\" (\"SiteHyenaToMove\")) (move Remove (where \"Hyena\" Shared) (then (forEach Site (sites Board) (if (is Occupied (site)) (remove (site) count:(size Stack at:(site))))))) (move (from (where \"Hyena\" Shared)) (to (\"SiteHyenaToMove\")) (then (forEach Value min:1 max:(- (* 2 (\"ThrowValue\")) 1) (if (is Occupied (\"SiteToMoveOnTrack\" from:(last From) (value))) (remove (\"SiteToMoveOnTrack\" from:(last From) (value)) count:(size Stack at:(\"SiteToMoveOnTrack\" from:(last From) (value))))))))) (or (forEach Piece) (forEach Piece container:(mover))))))) (end { (forEach Player if:(and { (> (\"HyenaPlayer\") 0) (!= (player) (\"HyenaPlayer\")) (\"IsOffBoard\" (where \"Hyena\" Shared))}) (result Player Loss)) (if (and (= (id Mover) (\"HyenaPlayer\")) (\"IsOffBoard\" (where \"Hyena\" Shared))) (result Mover Win)) (forEach Player if:(and (!= (player) (\"HyenaPlayer\")) (no Pieces of:(player))) (result Player Loss))})))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nChecks if a specific piece is threatened by any other enemy piece.\n\n### Response:\n",
    "completion": "(define \"IsInCheck\" (is Threatened (id #1 #2) #3))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Checks if a specific piece is threatened by any other enemy piece."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nA size 7 board is currently selected -> A size 9 board is currently selected\nA group penalty of 0 points is currently selected -> A group penalty of 2 points is currently selected\n\n### Input:\n(define \"UpdateScore\" (set Score Mover (- (count Sites in:(sites Occupied by:Mover)) (* 0 (count Groups Orthogonal if:(is Mover (who at:(to)))))))) (define \"Grow\" (\"PlaceGrey\" (then (if (can Move (\"PlaceGrey\" ~)) (moveAgain) (do (\"ReplaceAllGrey\") next:(\"UpdateScore\")))))) (define \"ReplaceAllGrey\" (add (to (sites Occupied by:Neutral) (apply (remove (to)))) (then (if (!= 1 (var \"HasGrown\")) (and (set Var \"HasGrown\" 1) (if (= (id P2) (mover)) (and (set Var \"MoveThatMustBePlant\" (count Moves)) (moveAgain)))))))) (define \"PlaceGrey\" (do (move Add (piece \"Marker0\") (to (sites Empty) if:(< 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(> 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))) #1)) (define \"Plant\" (move Add (to (sites Empty) if:(= 0 (count Sites in:(sites Around (to) Own Orthogonal)))) (then (\"UpdateScore\")))) (game \"Symple\" (players 2) (equipment { (board (square 7) use:Vertex) (piece \"Marker\" Each) (piece \"Marker\" Neutral)}) (rules (play (if (= (count Moves) (var \"MoveThatMustBePlant\")) (\"Plant\") (if (= 0 (count MovesThisTurn)) (or (\"Plant\") (\"Grow\")) (\"Grow\")))) (end (if (is Full) (byScore)))))\n\n### Response:\n",
    "completion": "(define \"UpdateScore\" (set Score Mover (- (count Sites in:(sites Occupied by:Mover)) (* 2 (count Groups Orthogonal if:(is Mover (who at:(to)))))))) (define \"Grow\" (\"PlaceGrey\" (then (if (can Move (\"PlaceGrey\" ~)) (moveAgain) (do (\"ReplaceAllGrey\") next:(\"UpdateScore\")))))) (define \"ReplaceAllGrey\" (add (to (sites Occupied by:Neutral) (apply (remove (to)))) (then (if (!= 1 (var \"HasGrown\")) (and (set Var \"HasGrown\" 1) (if (= (id P2) (mover)) (and (set Var \"MoveThatMustBePlant\" (count Moves)) (moveAgain)))))))) (define \"PlaceGrey\" (do (move Add (piece \"Marker0\") (to (sites Empty) if:(< 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(> 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))) #1)) (define \"Plant\" (move Add (to (sites Empty) if:(= 0 (count Sites in:(sites Around (to) Own Orthogonal)))) (then (\"UpdateScore\")))) (game \"Symple\" (players 2) (equipment { (board (square 9) use:Vertex) (piece \"Marker\" Each) (piece \"Marker\" Neutral)}) (rules (play (if (= (count Moves) (var \"MoveThatMustBePlant\")) (\"Plant\") (if (= 0 (count MovesThisTurn)) (or (\"Plant\") (\"Grow\")) (\"Grow\")))) (end (if (is Full) (byScore)))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nA size 7 board is currently selected -> A size 9 board is currently selected\nA group penalty of 0 points is currently selected -> A group penalty of 2 points is currently selected",
    "_var_input": "(define \"UpdateScore\" (set Score Mover (- (count Sites in:(sites Occupied by:Mover)) (* 0 (count Groups Orthogonal if:(is Mover (who at:(to)))))))) (define \"Grow\" (\"PlaceGrey\" (then (if (can Move (\"PlaceGrey\" ~)) (moveAgain) (do (\"ReplaceAllGrey\") next:(\"UpdateScore\")))))) (define \"ReplaceAllGrey\" (add (to (sites Occupied by:Neutral) (apply (remove (to)))) (then (if (!= 1 (var \"HasGrown\")) (and (set Var \"HasGrown\" 1) (if (= (id P2) (mover)) (and (set Var \"MoveThatMustBePlant\" (count Moves)) (moveAgain)))))))) (define \"PlaceGrey\" (do (move Add (piece \"Marker0\") (to (sites Empty) if:(< 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(> 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))) #1)) (define \"Plant\" (move Add (to (sites Empty) if:(= 0 (count Sites in:(sites Around (to) Own Orthogonal)))) (then (\"UpdateScore\")))) (game \"Symple\" (players 2) (equipment { (board (square 7) use:Vertex) (piece \"Marker\" Each) (piece \"Marker\" Neutral)}) (rules (play (if (= (count Moves) (var \"MoveThatMustBePlant\")) (\"Plant\") (if (= 0 (count MovesThisTurn)) (or (\"Plant\") (\"Grow\")) (\"Grow\")))) (end (if (is Full) (byScore)))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n4x12-20 board. Play begins with a number of counters that is three times the number of holes in a row minus two for a game with an even number of holes in a row; three times the number of holes minus one for odd. Counters are distributed beginning in the leftmost hole in the outer row, placing two counters in each hole in an anti-clockwise direction. Play begins from any of the player's holes, sowing anti-clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues, unless a capture can be made. Captures are made when the final counter falls into an occupied hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. These are then sown from the hole following the one from which the capture occurred. If the final counter falls into an empty hole, the turn is over. Single counters cannot be sown. Play ends when one player cannot move. Each player has 12 holes.\n\n### Response:\n",
    "completion": "(define \"PiecesOwnedBy\" (+ (count Cell at:(handSite #1)) (count in:(sites #1)))) (define \"MoveAgainAfterCapture\" (is Pending)) (define \"PlayFromNextHole\" (sites {(value Pending)})) (define \"NextHole\" (if (is Mover P1) (\"NextSiteOnTrack\" 1 from:(to) \"Track1\") (\"NextSiteOnTrack\" 1 from:(to) \"Track2\"))) (define \"Columns\" 12) (game \"Owela (Benguela)\" (players 2) (equipment { (mancalaBoard 4 \"Columns\" store:None { (track \"Track1\" \"0,E,N1,W\" loop:True P1) (track \"Track2\" \"24,E,N1,W\" loop:True P2)}) (regions \"Home\" P1 (sites Track \"Track1\")) (regions \"Home\" P2 (sites Track \"Track2\")) (regions \"Inner\" P1 (difference (sites Track \"Track1\") (sites Bottom))) (regions \"Inner\" P2 (difference (sites Track \"Track2\") (sites Top))) (regions \"Outer\" P1 (sites Bottom)) (regions \"Outer\" P2 (sites Top)) (regions \"InnerInit\" P1 (sites {19..23})) (regions \"InnerInit\" P2 (sites {24..28})) (piece \"Seed\" Shared) (hand Each)}) (rules (start (set Count 2 to:(union {(sites P1 \"Outer\") (sites P1 \"InnerInit\") (sites P2 \"Outer\") (sites P2 \"InnerInit\")}))) (play (move Select (from (if (\"SameTurn\") (if \"MoveAgainAfterCapture\" \"PlayFromNextHole\" \"LastHoleSowed\") (sites Mover \"Home\")) if:(> (count at:(from)) 1)) (then (sow \"Track\" owner:(mover) apply:(if (> (count at:(to)) 1) (if (and (is In (to) (sites Mover \"Inner\")) (> (count at:(\"OppositePit\" (to))) 0)) (and { (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (fromTo (from (\"OppositePit\" (to))) (to (handSite Mover)) count:(count at:(\"OppositePit\" (to)))) (if (> (count at:(\"OppositeOuterPit\" (to))) 0) (fromTo (from (\"OppositeOuterPit\" (to))) (to (handSite Mover)) count:(count at:(\"OppositeOuterPit\" (to))))) (if (> (count at:\"NextHole\") 1) (and (set Pending \"NextHole\") (moveAgain)))}) (moveAgain))))))) (end (\"MancalaByScoreWhen\" (no Moves Mover)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "4x12-20 board. Play begins with a number of counters that is three times the number of holes in a row minus two for a game with an even number of holes in a row; three times the number of holes minus one for odd. Counters are distributed beginning in the leftmost hole in the outer row, placing two counters in each hole in an anti-clockwise direction. Play begins from any of the player's holes, sowing anti-clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues, unless a capture can be made. Captures are made when the final counter falls into an occupied hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. These are then sown from the hole following the one from which the capture occurred. If the final counter falls into an empty hole, the turn is over. Single counters cannot be sown. Play ends when one player cannot move. Each player has 12 holes."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThe board graph is initially coloured with a neutral colour. Players take turns removing colour from a coloured edge. The game is won by the player who removes the last cycle from the coloured graph. The game is played on the Graph1.\n\n### Response:\n",
    "completion": "(game \"Nedilmarth\" (players 2) (equipment { (board (merge (scale 0.707 (concentric {1 8})) (shift -.5 -.5 (square 2))) use:Edge) (piece \"Marker\" Neutral)}) (rules (start { (set Neutral Edge (sites Board Edge))}) (play (move Remove (sites Occupied by:Neutral on:Edge))) (end (if (is Tree Neutral) (result Mover Win)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "The board graph is initially coloured with a neutral colour. Players take turns removing colour from a coloured edge. The game is won by the player who removes the last cycle from the coloured graph. The game is played on the Graph1."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nEach player begins with 21 pieces, arranges on the 21 intersections of three consecutive radii. Players alternate turns moving to an empty adjacent spot. Captures are made by hopping over an opponent's piece. The player who captures all of the other player's pieces wins. \n\n### Response:\n",
    "completion": "(game \"Gol Ekuish\" (players 2) (equipment { (board (concentric {1 6 6 6 6 6 6 6}) use:Vertex) (piece \"Counter\" Each (or (\"HopRotationalCapture\") (\"StepRotationalToEmpty\")))}) (rules (start { (place \"Counter1\" (sites {2..4 8..10 14..16 20..22 26..28 32..34 38..40})) (place \"Counter2\" (sites {1 7 13 19 25 31 37 5 6 11 12 17 18 23 24 29 30 35 36 41 42}))}) (play (forEach Piece)) (end (\"NoMoves\" Loss))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Each player begins with 21 pieces, arranges on the 21 intersections of three consecutive radii. Players alternate turns moving to an empty adjacent spot. Captures are made by hopping over an opponent's piece. The player who captures all of the other player's pieces wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n5x5 board. Twelve pieces per player, arranged in the two rows in front of each player, and in the right two squares in the central row (the central space is empty). Players alternate turns moving a piece to an adjacent orthogonal space. The player may capture an opponent's piece by hopping over it in an orthogonal direction. Multiple hops are allowed in the same turn, but captures are not compulsory, The player who captures all of their opponent's pieces wins. \n\n### Response:\n",
    "completion": "(game \"Koruboddo\" (players 2) (equipment { (board (square 5)) (piece \"Marker\" Each (or (\"HopOrthogonalSequenceCapture\") (\"StepOrthogonalToEmpty\")))}) (rules (start { (place \"Marker1\" (union {(sites Row 0) (sites Row 1) (sites {\"A3\" \"B3\"})})) (place \"Marker2\" (union {(sites Row 3) (sites Row 4) (sites {\"D3\" \"E3\"})}))}) (play (if \"SameTurn\" (or (\"HopOrthogonalSequenceCaptureAgain\") (move Pass)) (forEach Piece))) (end (\"CaptureAll\" Next))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "5x5 board. Twelve pieces per player, arranged in the two rows in front of each player, and in the right two squares in the central row (the central space is empty). Players alternate turns moving a piece to an adjacent orthogonal space. The player may capture an opponent's piece by hopping over it in an orthogonal direction. Multiple hops are allowed in the same turn, but captures are not compulsory, The player who captures all of their opponent's pieces wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nOne player is the rabbit, and the other player plays with twelve other pieces. They may also play with either ten or eleven pieces instead of twelve. The pieces move along the lines. The goal is to corner the rabbit so that it cannot move. The rabbit may hop over the other pieces to capture them. The rabbit wins by reducing the opponent to nine pieces. Played on a Alquerque Board. The hare can jump to capture.\n\n### Response:\n",
    "completion": "(game \"Cercar La Liebre\" (players 2) (equipment { (\"AlquerqueBoard\" 5 5) (piece \"Counter\" P1 \"StepToEmpty\") (piece \"Hare\" P2 (or \"HopCapture\" (if \"SameTurn\" (move Pass) \"StepToEmpty\")))}) (rules (start { (place \"Counter1\" (union {(expand (sites Bottom)) (sites {\"A3\" \"E3\"})})) (place \"Hare2\" (centrePoint))}) (play (forEach Piece)) (end (\"NoMovesLossAndLessNumPiecesPlayerLoss\" P1 9))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "One player is the rabbit, and the other player plays with twelve other pieces. They may also play with either ten or eleven pieces instead of twelve. The pieces move along the lines. The goal is to corner the rabbit so that it cannot move. The rabbit may hop over the other pieces to capture them. The rabbit wins by reducing the opponent to nine pieces. Played on a Alquerque Board. The hare can jump to capture."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nThe game is played on a 4x4 board. -> The game is played on a 5x5 board.\n\n### Input:\n(define \"ReachedTarget\" (is In (last To) (sites Mover))) (game \"Breakback\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 4)) (piece \"Pawn\" Each (or { \"StepForwardToEmpty\" (move Step (directions {FR FL}) (to if:(or (is Empty (to)) (\"IsEnemyAt\" (to))) (apply (remove (to)))))})) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (expand (sites Bottom))) (place \"Pawn2\" (expand (sites Top)))}) (play (priority (forEach Piece (\"StepBackwardToEmpty\")) (forEach Piece))) (end (if \"ReachedTarget\" (result Mover Win)))))\n\n### Response:\n",
    "completion": "(define \"ReachedTarget\" (is In (last To) (sites Mover))) (game \"Breakback\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 5)) (piece \"Pawn\" Each (or { \"StepForwardToEmpty\" (move Step (directions {FR FL}) (to if:(or (is Empty (to)) (\"IsEnemyAt\" (to))) (apply (remove (to)))))})) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (expand (sites Bottom))) (place \"Pawn2\" (expand (sites Top)))}) (play (priority (forEach Piece (\"StepBackwardToEmpty\")) (forEach Piece))) (end (if \"ReachedTarget\" (result Mover Win)))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nThe game is played on a 4x4 board. -> The game is played on a 5x5 board.",
    "_var_input": "(define \"ReachedTarget\" (is In (last To) (sites Mover))) (game \"Breakback\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 4)) (piece \"Pawn\" Each (or { \"StepForwardToEmpty\" (move Step (directions {FR FL}) (to if:(or (is Empty (to)) (\"IsEnemyAt\" (to))) (apply (remove (to)))))})) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (expand (sites Bottom))) (place \"Pawn2\" (expand (sites Top)))}) (play (priority (forEach Piece (\"StepBackwardToEmpty\")) (forEach Piece))) (end (if \"ReachedTarget\" (result Mover Win)))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nEach row has 9 holes. -> Each row has 11 holes.\n\n### Input:\n(define \"Move\" (or { (if (\"IsInTrack\" (site) \"HomeTrack\") (move (from (site)) (to (\"NextSiteOnTrack\" (\"ThrowValue\") from:(site) \"HomeTrack\") \"CaptureEnemyPiece\") count:(count at:(site)))) (if (\"IsInTrack\" (site) \"MiddleTrack\") (move (from (site)) (to (\"NextSiteOnTrack\" (\"ThrowValue\") from:(site) \"MiddleTrack\") \"CaptureEnemyPiece\") count:(count at:(site)))) (if (\"IsInTrack\" (site) \"EnemyTrack\") (if (if (is In (site) (sites Next \"Home\")) True (and (!= 0 (\"CountPiecesInHome\" Next)) (\"PieceDidNotGoToEnemyHome\" (site)))) (move (from (site)) (to (\"NextSiteOnTrack\" (\"ThrowValue\") from:(site) \"EnemyTrack\") \"CaptureEnemyPiece\") count:(count at:(site)) (then (if (and (is In (last To) (sites Next \"Home\")) (\"PieceDidNotGoToEnemyHome\" (last To))) (\"PieceGoesToEnemyHome\" (last To)))))))})) (define \"IsInTrack\" (is In #1 (sites Track Mover #2))) (define \"PieceDidNotGoToEnemyHome\" (= 0 (state at:#1))) (define \"PieceGoesToEnemyHome\" (set State at:#1 1)) (define \"CountPiecesInHome\" (count Pieces #1 in:(sites #1 \"Home\"))) (define \"CaptureEnemyPiece\" (apply if:(\"IsEnemyAt\" (to)) (remove (to) count:(count at:(to))))) (define \"Tab\" (= 1 (\"ThrowValue\"))) (define \"SpecialThrows\" (is In (\"ThrowValue\") (sites {1 4 6}))) (define \"ThrowValue\" (mapEntry (count Pips))) (game \"Tab\" (players 2) (equipment { (board (rectangle 4 9) { (track \"HomeTrack1\" \"0,E,N1,W\" P1 directed:True) (track \"HomeTrack2\" \"35,W,S1,E\" P2 directed:True) (track \"MiddleTrack\" \"17,W,N1,E\" loop:True) (track \"EnemyTrack1\" \"18,E,N1,W,S1,E\" P1 directed:True) (track \"EnemyTrack2\" \"17,W,S1,E,N1,W\" P2 directed:True)} use:Vertex) (piece \"Stick\" Each) (regions \"AllSites\" (sites Board)) (\"StickDice\" 4) (map \"Throw\" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top))}) (rules (start { (place \"Stick1\" (sites Bottom)) (place \"Stick2\" (sites Top))}) phases:{ (phase \"InitGame\" (play (\"RollMove\" (move Pass) (then (if (\"Tab\") (moveAgain))))) (nextPhase (\"Tab\") \"Play\")) (phase \"Play\" (play (\"RollMove\" (forEach Site (sites Occupied by:Mover) (\"Move\")) (then (if (\"SpecialThrows\") (moveAgain))))))} (end (\"CaptureAll\" Next))))\n\n### Response:\n",
    "completion": "(define \"Move\" (or { (if (\"IsInTrack\" (site) \"HomeTrack\") (move (from (site)) (to (\"NextSiteOnTrack\" (\"ThrowValue\") from:(site) \"HomeTrack\") \"CaptureEnemyPiece\") count:(count at:(site)))) (if (\"IsInTrack\" (site) \"MiddleTrack\") (move (from (site)) (to (\"NextSiteOnTrack\" (\"ThrowValue\") from:(site) \"MiddleTrack\") \"CaptureEnemyPiece\") count:(count at:(site)))) (if (\"IsInTrack\" (site) \"EnemyTrack\") (if (if (is In (site) (sites Next \"Home\")) True (and (!= 0 (\"CountPiecesInHome\" Next)) (\"PieceDidNotGoToEnemyHome\" (site)))) (move (from (site)) (to (\"NextSiteOnTrack\" (\"ThrowValue\") from:(site) \"EnemyTrack\") \"CaptureEnemyPiece\") count:(count at:(site)) (then (if (and (is In (last To) (sites Next \"Home\")) (\"PieceDidNotGoToEnemyHome\" (last To))) (\"PieceGoesToEnemyHome\" (last To)))))))})) (define \"IsInTrack\" (is In #1 (sites Track Mover #2))) (define \"PieceDidNotGoToEnemyHome\" (= 0 (state at:#1))) (define \"PieceGoesToEnemyHome\" (set State at:#1 1)) (define \"CountPiecesInHome\" (count Pieces #1 in:(sites #1 \"Home\"))) (define \"CaptureEnemyPiece\" (apply if:(\"IsEnemyAt\" (to)) (remove (to) count:(count at:(to))))) (define \"Tab\" (= 1 (\"ThrowValue\"))) (define \"SpecialThrows\" (is In (\"ThrowValue\") (sites {1 4 6}))) (define \"ThrowValue\" (mapEntry (count Pips))) (game \"Tab\" (players 2) (equipment { (board (rectangle 4 11) { (track \"HomeTrack1\" \"0,E,N1,W\" P1 directed:True) (track \"HomeTrack2\" \"43,W,S1,E\" P2 directed:True) (track \"MiddleTrack\" \"21,W,N1,E\" loop:True) (track \"EnemyTrack1\" \"22,E,N1,W,S1,E\" P1 directed:True) (track \"EnemyTrack2\" \"21,W,S1,E,N1,W\" P2 directed:True)} use:Vertex) (piece \"Stick\" Each) (regions \"AllSites\" (sites Board)) (\"StickDice\" 4) (map \"Throw\" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top))}) (rules (start { (place \"Stick1\" (sites Bottom)) (place \"Stick2\" (sites Top))}) phases:{ (phase \"InitGame\" (play (\"RollMove\" (move Pass) (then (if (\"Tab\") (moveAgain))))) (nextPhase (\"Tab\") \"Play\")) (phase \"Play\" (play (\"RollMove\" (forEach Site (sites Occupied by:Mover) (\"Move\")) (then (if (\"SpecialThrows\") (moveAgain))))))} (end (\"CaptureAll\" Next))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nEach row has 9 holes. -> Each row has 11 holes.",
    "_var_input": "(define \"Move\" (or { (if (\"IsInTrack\" (site) \"HomeTrack\") (move (from (site)) (to (\"NextSiteOnTrack\" (\"ThrowValue\") from:(site) \"HomeTrack\") \"CaptureEnemyPiece\") count:(count at:(site)))) (if (\"IsInTrack\" (site) \"MiddleTrack\") (move (from (site)) (to (\"NextSiteOnTrack\" (\"ThrowValue\") from:(site) \"MiddleTrack\") \"CaptureEnemyPiece\") count:(count at:(site)))) (if (\"IsInTrack\" (site) \"EnemyTrack\") (if (if (is In (site) (sites Next \"Home\")) True (and (!= 0 (\"CountPiecesInHome\" Next)) (\"PieceDidNotGoToEnemyHome\" (site)))) (move (from (site)) (to (\"NextSiteOnTrack\" (\"ThrowValue\") from:(site) \"EnemyTrack\") \"CaptureEnemyPiece\") count:(count at:(site)) (then (if (and (is In (last To) (sites Next \"Home\")) (\"PieceDidNotGoToEnemyHome\" (last To))) (\"PieceGoesToEnemyHome\" (last To)))))))})) (define \"IsInTrack\" (is In #1 (sites Track Mover #2))) (define \"PieceDidNotGoToEnemyHome\" (= 0 (state at:#1))) (define \"PieceGoesToEnemyHome\" (set State at:#1 1)) (define \"CountPiecesInHome\" (count Pieces #1 in:(sites #1 \"Home\"))) (define \"CaptureEnemyPiece\" (apply if:(\"IsEnemyAt\" (to)) (remove (to) count:(count at:(to))))) (define \"Tab\" (= 1 (\"ThrowValue\"))) (define \"SpecialThrows\" (is In (\"ThrowValue\") (sites {1 4 6}))) (define \"ThrowValue\" (mapEntry (count Pips))) (game \"Tab\" (players 2) (equipment { (board (rectangle 4 9) { (track \"HomeTrack1\" \"0,E,N1,W\" P1 directed:True) (track \"HomeTrack2\" \"35,W,S1,E\" P2 directed:True) (track \"MiddleTrack\" \"17,W,N1,E\" loop:True) (track \"EnemyTrack1\" \"18,E,N1,W,S1,E\" P1 directed:True) (track \"EnemyTrack2\" \"17,W,S1,E,N1,W\" P2 directed:True)} use:Vertex) (piece \"Stick\" Each) (regions \"AllSites\" (sites Board)) (\"StickDice\" 4) (map \"Throw\" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top))}) (rules (start { (place \"Stick1\" (sites Bottom)) (place \"Stick2\" (sites Top))}) phases:{ (phase \"InitGame\" (play (\"RollMove\" (move Pass) (then (if (\"Tab\") (moveAgain))))) (nextPhase (\"Tab\") \"Play\")) (phase \"Play\" (play (\"RollMove\" (forEach Site (sites Occupied by:Mover) (\"Move\")) (then (if (\"SpecialThrows\") (moveAgain))))))} (end (\"CaptureAll\" Next))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThree concentric circles, with four diameters dividing it into eight equal sections. Twelve pieces per player, placed on the points on one half of the circle, leaving the central point open. Players alternate turns moving one of their pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to an empty spot immediately on the opposite side of the opponent's piece along the lines. The player who captures all of the opponent's pieces wins. \n\n### Response:\n",
    "completion": "(game \"Bara Guti (Bihar)\" (players 2) (equipment { (board (concentric {1 8 8 8}) use:Vertex) (piece \"Counter\" Each (or (\"HopRotationalCapture\") (\"StepRotationalToEmpty\")))}) (rules (start { (place \"Counter1\" (sites {2..5 10..13 18..21})) (place \"Counter2\" (sites {1 9 17 6..8 14..16 22..24}))}) (play (forEach Piece)) (end (\"CaptureAll\" Next))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Three concentric circles, with four diameters dividing it into eight equal sections. Twelve pieces per player, placed on the points on one half of the circle, leaving the central point open. Players alternate turns moving one of their pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to an empty spot immediately on the opposite side of the opponent's piece along the lines. The player who captures all of the opponent's pieces wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nEach row has 9 holes. -> Each row has 10 holes.\n\n### Input:\n(define \"AllSitesNoMoreThanOne\" (all Sites (sites Mover \"Home\") if:(>= 1 (count at:(site))))) (define \"NextHole\" (\"NextSiteOnTrack\" #2 from:#1 \"Track\")) (define \"NoPiece\" (all Sites (sites Player) if:(= 0 (count at:(site))))) (define \"Columns\" 9) (game \"Njombwa (Two Counters)\" (players 2) (equipment { (mancalaBoard 4 \"Columns\" store:None { (track \"Track1\" \"0,E,N1,W\" loop:True P1) (track \"Track2\" \"18,E,N1,W\" loop:True P2)}) (regions \"Home\" P1 (sites Track \"Track1\")) (regions \"Home\" P2 (sites Track \"Track2\")) (regions \"Inner\" P1 (difference (sites Track \"Track1\") (sites Bottom))) (regions \"Inner\" P2 (difference (sites Track \"Track2\") (sites Top))) (piece \"Seed\" Shared)}) (rules (start { (set Count 2 to:(difference (sites Board) (sites {9 (+ 1 9) (- (* 9 3) 1) (- (* 9 3) 2)}))) (set Count 1 to:(sites {(+ 9 1) (- (* 9 3) 2)}))}) (play (if (\"AllSitesNoMoreThanOne\") (move Select (from (sites Mover \"Home\") if:(and (is Occupied (from)) (is Empty (\"NextHole\" (from) 1)))) (then (sow \"Track\" owner:(mover)))) (move Select (from (if (\"SameTurn\") \"LastHoleSowed\" (sites Mover \"Home\")) if:(> (count at:(from)) 1)) (then (sow \"Track\" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (is In (to) (sites Mover \"Inner\")) (is Occupied (\"OppositePit\" (to)))) (and (remove (\"OppositePit\" (to))) (if (is Occupied (\"OppositeOuterPit\" (to))) (remove (\"OppositeOuterPit\" (to)))))))))))) (end (forEach NonMover if:(\"NoPiece\") (result Player Loss)))))\n\n### Response:\n",
    "completion": "(define \"AllSitesNoMoreThanOne\" (all Sites (sites Mover \"Home\") if:(>= 1 (count at:(site))))) (define \"NextHole\" (\"NextSiteOnTrack\" #2 from:#1 \"Track\")) (define \"NoPiece\" (all Sites (sites Player) if:(= 0 (count at:(site))))) (define \"Columns\" 10) (game \"Njombwa (Two Counters)\" (players 2) (equipment { (mancalaBoard 4 \"Columns\" store:None { (track \"Track1\" \"0,E,N1,W\" loop:True P1) (track \"Track2\" \"20,E,N1,W\" loop:True P2)}) (regions \"Home\" P1 (sites Track \"Track1\")) (regions \"Home\" P2 (sites Track \"Track2\")) (regions \"Inner\" P1 (difference (sites Track \"Track1\") (sites Bottom))) (regions \"Inner\" P2 (difference (sites Track \"Track2\") (sites Top))) (piece \"Seed\" Shared)}) (rules (start { (set Count 2 to:(difference (sites Board) (sites {10 (+ 1 10) (- (* 10 3) 1) (- (* 10 3) 2)}))) (set Count 1 to:(sites {(+ 10 1) (- (* 10 3) 2)}))}) (play (if (\"AllSitesNoMoreThanOne\") (move Select (from (sites Mover \"Home\") if:(and (is Occupied (from)) (is Empty (\"NextHole\" (from) 1)))) (then (sow \"Track\" owner:(mover)))) (move Select (from (if (\"SameTurn\") \"LastHoleSowed\" (sites Mover \"Home\")) if:(> (count at:(from)) 1)) (then (sow \"Track\" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (is In (to) (sites Mover \"Inner\")) (is Occupied (\"OppositePit\" (to)))) (and (remove (\"OppositePit\" (to))) (if (is Occupied (\"OppositeOuterPit\" (to))) (remove (\"OppositeOuterPit\" (to)))))))))))) (end (forEach NonMover if:(\"NoPiece\") (result Player Loss)))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nEach row has 9 holes. -> Each row has 10 holes.",
    "_var_input": "(define \"AllSitesNoMoreThanOne\" (all Sites (sites Mover \"Home\") if:(>= 1 (count at:(site))))) (define \"NextHole\" (\"NextSiteOnTrack\" #2 from:#1 \"Track\")) (define \"NoPiece\" (all Sites (sites Player) if:(= 0 (count at:(site))))) (define \"Columns\" 9) (game \"Njombwa (Two Counters)\" (players 2) (equipment { (mancalaBoard 4 \"Columns\" store:None { (track \"Track1\" \"0,E,N1,W\" loop:True P1) (track \"Track2\" \"18,E,N1,W\" loop:True P2)}) (regions \"Home\" P1 (sites Track \"Track1\")) (regions \"Home\" P2 (sites Track \"Track2\")) (regions \"Inner\" P1 (difference (sites Track \"Track1\") (sites Bottom))) (regions \"Inner\" P2 (difference (sites Track \"Track2\") (sites Top))) (piece \"Seed\" Shared)}) (rules (start { (set Count 2 to:(difference (sites Board) (sites {9 (+ 1 9) (- (* 9 3) 1) (- (* 9 3) 2)}))) (set Count 1 to:(sites {(+ 9 1) (- (* 9 3) 2)}))}) (play (if (\"AllSitesNoMoreThanOne\") (move Select (from (sites Mover \"Home\") if:(and (is Occupied (from)) (is Empty (\"NextHole\" (from) 1)))) (then (sow \"Track\" owner:(mover)))) (move Select (from (if (\"SameTurn\") \"LastHoleSowed\" (sites Mover \"Home\")) if:(> (count at:(from)) 1)) (then (sow \"Track\" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (is In (to) (sites Mover \"Inner\")) (is Occupied (\"OppositePit\" (to)))) (and (remove (\"OppositePit\" (to))) (if (is Occupied (\"OppositeOuterPit\" (to))) (remove (\"OppositeOuterPit\" (to)))))))))))) (end (forEach NonMover if:(\"NoPiece\") (result Player Loss)))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nSeega rules applied to a 17x17 board. -> Kharebga rules applied to a 17x18 board.\n\n### Input:\n(define \"Custodial\" (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id #1)) (apply (remove (between)))) (to if:(\"FriendOrCentre\")))) (define \"JarlButNotTheExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (and (!= (between) (\"Castle\")) (not (is In (between) (sites \"OrthogonalSitesCentre\")))))) (define \"JarlAndExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (or (= (between) (\"Castle\")) (is In (between) (sites \"OrthogonalSitesCentre\"))))) (define \"FriendOrCentre\" (or (\"IsFriendAt\" (to)) (= (to) (\"Castle\")))) (define \"CaptureJarl\" (apply (trigger \"Surrounded\" P2))) (define \"JarlWasCaptured\" (is Triggered \"Surrounded\" P2)) (define \"Castle\" (centrePoint)) (define \"Custodial\" (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id #1)) (apply (remove (between)))) (to if:(\"FriendOrCentre\")))) (define \"JarlButNotTheExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (and (!= (between) (\"Castle\")) (not (is In (between) (sites \"OrthogonalSitesCentre\")))))) (define \"JarlAndExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (or (= (between) (\"Castle\")) (is In (between) (sites \"OrthogonalSitesCentre\"))))) (define \"FriendOrCentre\" (or (\"IsFriendAt\" (to)) (= (to) (\"Castle\")))) (define \"CaptureJarl\" (apply (trigger \"Surrounded\" P2))) (define \"JarlWasCaptured\" (is Triggered \"Surrounded\" P2)) (define \"Castle\" (centrePoint)) (define \"NoRepetition\" (meta (no Repeat))) (game \"Poprad Game\" (players 2) (equipment { (board (square 17)) (piece \"Marker\" Each (\"StepToEmpty\" Orthogonal (then (\"CustodialCapture\" Orthogonal (max 1))))) (hand Each)}) (rules (\"NoRepetition\") (start (place \"Marker\" \"Hand\" count:144)) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (and (is Occupied (handSite Mover)) (\"NewTurn\")) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) \"Capture\")) (\"PhaseMovePiece\" \"Capture\")} (end (\"HavingLessPiecesLoss\" Next 1))))\n\n### Response:\n",
    "completion": "(define \"Custodial\" (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id #1)) (apply (remove (between)))) (to if:(\"FriendOrCentre\")))) (define \"JarlButNotTheExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (and (!= (between) (\"Castle\")) (not (is In (between) (sites \"OrthogonalSitesCentre\")))))) (define \"JarlAndExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (or (= (between) (\"Castle\")) (is In (between) (sites \"OrthogonalSitesCentre\"))))) (define \"FriendOrCentre\" (or (\"IsFriendAt\" (to)) (= (to) (\"Castle\")))) (define \"CaptureJarl\" (apply (trigger \"Surrounded\" P2))) (define \"JarlWasCaptured\" (is Triggered \"Surrounded\" P2)) (define \"Castle\" (centrePoint)) (define \"Custodial\" (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id #1)) (apply (remove (between)))) (to if:(\"FriendOrCentre\")))) (define \"JarlButNotTheExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (and (!= (between) (\"Castle\")) (not (is In (between) (sites \"OrthogonalSitesCentre\")))))) (define \"JarlAndExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (or (= (between) (\"Castle\")) (is In (between) (sites \"OrthogonalSitesCentre\"))))) (define \"FriendOrCentre\" (or (\"IsFriendAt\" (to)) (= (to) (\"Castle\")))) (define \"CaptureJarl\" (apply (trigger \"Surrounded\" P2))) (define \"JarlWasCaptured\" (is Triggered \"Surrounded\" P2)) (define \"Castle\" (centrePoint)) (define \"NoRepetition\" (meta (no Repeat))) (game \"Poprad Game\" (players 2) (equipment { (board (rectangle 17 18)) (piece \"Marker\" Each (move Slide Orthogonal (then (\"CustodialCapture\" Orthogonal (max 1))))) (hand Each)}) (rules (\"NoRepetition\") (start (place \"Marker\" \"Hand\" count:152)) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (and (is Occupied (handSite Mover)) (\"NewTurn\")) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) \"Capture\")) (\"PhaseMovePiece\" \"Capture\")} (end (\"HavingLessPiecesLoss\" Next 1))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nSeega rules applied to a 17x17 board. -> Kharebga rules applied to a 17x18 board.",
    "_var_input": "(define \"Custodial\" (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id #1)) (apply (remove (between)))) (to if:(\"FriendOrCentre\")))) (define \"JarlButNotTheExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (and (!= (between) (\"Castle\")) (not (is In (between) (sites \"OrthogonalSitesCentre\")))))) (define \"JarlAndExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (or (= (between) (\"Castle\")) (is In (between) (sites \"OrthogonalSitesCentre\"))))) (define \"FriendOrCentre\" (or (\"IsFriendAt\" (to)) (= (to) (\"Castle\")))) (define \"CaptureJarl\" (apply (trigger \"Surrounded\" P2))) (define \"JarlWasCaptured\" (is Triggered \"Surrounded\" P2)) (define \"Castle\" (centrePoint)) (define \"Custodial\" (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id #1)) (apply (remove (between)))) (to if:(\"FriendOrCentre\")))) (define \"JarlButNotTheExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (and (!= (between) (\"Castle\")) (not (is In (between) (sites \"OrthogonalSitesCentre\")))))) (define \"JarlAndExpandedCentre\" (and (= (what at:(between)) (id \"Jarl2\")) (or (= (between) (\"Castle\")) (is In (between) (sites \"OrthogonalSitesCentre\"))))) (define \"FriendOrCentre\" (or (\"IsFriendAt\" (to)) (= (to) (\"Castle\")))) (define \"CaptureJarl\" (apply (trigger \"Surrounded\" P2))) (define \"JarlWasCaptured\" (is Triggered \"Surrounded\" P2)) (define \"Castle\" (centrePoint)) (define \"NoRepetition\" (meta (no Repeat))) (game \"Poprad Game\" (players 2) (equipment { (board (square 17)) (piece \"Marker\" Each (\"StepToEmpty\" Orthogonal (then (\"CustodialCapture\" Orthogonal (max 1))))) (hand Each)}) (rules (\"NoRepetition\") (start (place \"Marker\" \"Hand\" count:144)) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (and (is Occupied (handSite Mover)) (\"NewTurn\")) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) \"Capture\")) (\"PhaseMovePiece\" \"Capture\")} (end (\"HavingLessPiecesLoss\" Next 1))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThere are three red ships and three black ships. The remainder\n            of the cells contain white icebergs. The two players, Red and Black, take turns\n            moving one of their own ships, one move per turn, starting with Red. Players are\n            not allowed to pass.\n            \n            MOVES:\n            You must move one of your ships to an adjacent cell which doesn't contain\n            another ship. By moving to a cell containing an iceberg, you capture the iceberg,\n            and your score increases by 1.\n            \n            MOVE DIRECTION:\n            You must select one of your ships to move, and move it closer to its closest\n            iceberg. Distance is measured by the number of cells between ship and iceberg\n            along the shortest path of cells that connects them, going around other ships. If\n            the ship you've chosen to move has icebergs adjacent to it, you must capture one\n            of them.\n            \n            OBJECT OF THE GAME:\n            The goal is to capture the majority of the icebergs. On the default size 5 board, there are 55 icebergs starting out. If you capture 28 of them, you\n        win. A size 5 board is currently selected\n\n### Response:\n",
    "completion": "(define \"OntoEmptyOrIceberg\" (step (to if:(or (= (id Neutral) (who at:(to))) (is Empty (to)))))) (define \"NearestIcebergs\" (intersection (sites Occupied by:Neutral) (sites Distance (\"OntoEmptyOrIceberg\") from:(from) (exact (\"DistanceToNearestIceberg\"))))) (define \"DistanceToNearestIceberg\" (count Steps (\"OntoEmptyOrIceberg\") (from) (sites Occupied by:Neutral))) (game \"Icebreaker\" (players 2) (equipment { (board (hex 5)) (piece \"Disc\" Each (move Step (to if:(and (or (= (id Neutral) (who at:(to))) (is Empty (to))) (= 1 (- (count Steps (\"OntoEmptyOrIceberg\") (from) (\"NearestIcebergs\")) (count Steps (\"OntoEmptyOrIceberg\") (to) (\"NearestIcebergs\"))))) (apply (if (is Occupied (to)) (and (remove (to)) (addScore Mover 1))))))) (piece \"Disc\" Neutral)}) (rules (start { (place \"Disc0\" (difference (sites Board) (sites Corners))) (place \"Disc1\" (sites Around (centrePoint) distance:(- 5 1) NNW)) (place \"Disc1\" (sites Around (centrePoint) distance:(- 5 1) E)) (place \"Disc1\" (sites Around (centrePoint) distance:(- 5 1) SSW)) (place \"Disc2\" (sites Around (centrePoint) distance:(- 5 1) NNE)) (place \"Disc2\" (sites Around (centrePoint) distance:(- 5 1) W)) (place \"Disc2\" (sites Around (centrePoint) distance:(- 5 1) SSE))}) (play (forEach Piece Mover)) (end (if (or (< (/ (- (count Sites in:(sites Board)) 6) 2) (score P1)) (< (/ (- (count Sites in:(sites Board)) 6) 2) (score P2))) (byScore)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "There are three red ships and three black ships. The remainder\n            of the cells contain white icebergs. The two players, Red and Black, take turns\n            moving one of their own ships, one move per turn, starting with Red. Players are\n            not allowed to pass.\n            \n            MOVES:\n            You must move one of your ships to an adjacent cell which doesn't contain\n            another ship. By moving to a cell containing an iceberg, you capture the iceberg,\n            and your score increases by 1.\n            \n            MOVE DIRECTION:\n            You must select one of your ships to move, and move it closer to its closest\n            iceberg. Distance is measured by the number of cells between ship and iceberg\n            along the shortest path of cells that connects them, going around other ships. If\n            the ship you've chosen to move has icebergs adjacent to it, you must capture one\n            of them.\n            \n            OBJECT OF THE GAME:\n            The goal is to capture the majority of the icebergs. On the default size 5 board, there are 55 icebergs starting out. If you capture 28 of them, you\n        win. A size 5 board is currently selected"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nChecks if a player has no legal moves and the game ends in a draw.\n\n### Response:\n",
    "completion": "(define \"DrawIfNoMoves\" (if (no Moves #1) (result Mover Draw)))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Checks if a player has no legal moves and the game ends in a draw."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayers take turns placing their pieces on a space on the board, with the goal of connecting all three sides of the triangle with their pieces. Corners count as belonging to both sides they touch. \n\n### Response:\n",
    "completion": "(game \"Y (Hex)\" (players 2) (equipment { (board (tri Hexagon 7) use:Vertex) (piece \"Marker\" Each) (regions \"SSW\" {(sites Side S) (sites Side SW)}) (regions \"NNW\" {(sites Side NW) (sites Side N)}) (regions \"NESE\" {(sites Side NE) (sites Side SE)})}) (rules (play (move Add (to (sites Empty)))) (end (if (is Connected { (sites \"SSW\") (sites \"NNW\") (sites \"NESE\")}) (result Mover Win)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Players take turns placing their pieces on a space on the board, with the goal of connecting all three sides of the triangle with their pieces. Corners count as belonging to both sides they touch. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayed on a 5x5 board. There are 3 'Musketeer' pieces and 22 'Enemy' pieces. Musketeers can only move by capturing enemies on any adjacent space. Enemies can only move to empty adjacent spaces. Enemies win if all three musketeers are ever on the same line or column. Musketeers win as soon as they run out of legal moves. \n\n### Response:\n",
    "completion": "(game \"Three Musketeers\" (players 2) (equipment { (board (square 5)) (piece \"Musketeer\" P1 (move Step Orthogonal (to if:(\"IsEnemyAt\" (to)) (apply (remove (to)))))) (piece \"Enemy\" P2 (\"StepOrthogonalToEmpty\"))}) (rules (start { (place \"Musketeer1\" {\"A1\" \"C3\" \"E5\"}) (place \"Enemy2\" (difference (sites Board) (sites {\"A1\" \"C3\" \"E5\"})))}) (play (forEach Piece)) (end { (if (no Moves P1) (result P1 Win)) (if (and (is Mover P1) (is Line 3 Orthogonal contiguous:False)) (result P2 Win))})))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Played on a 5x5 board. There are 3 'Musketeer' pieces and 22 'Enemy' pieces. Musketeers can only move by capturing enemies on any adjacent space. Enemies can only move to empty adjacent spaces. Enemies win if all three musketeers are ever on the same line or column. Musketeers win as soon as they run out of legal moves. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nTriangle-8 Board (36) -> Triangle-15 Board (120)\n\n### Input:\n(define \"EdgesOfSide\" (intersection (sites Outer Edge) (forEach of:(difference #1 (sites Corners Vertex)) (sites Incident Edge of:Vertex at:(site))))) (define \"BoardColour\" (colour 215 203 170)) (define \"P2Colour\" (colour White)) (define \"P1Colour\" (colour DarkGreen)) (define \"IsConnectedPlayer\" (is Connected 3 {\"Side1\" \"Side2\" \"Side3\"})) (define \"DefectorMove\" (priority (move Add (to (sites Occupied by:Next) if:(< \"MoverLimit\" (count Pieces Next in:(sites Around (to) Orthogonal))) (apply (remove (to)))) (then (moveAgain))) (\"AddToEmpty\" ~))) (define \"AddToEmpty\" (move Add (to (sites Empty)) #1)) (define \"MoverLimit\" (count Pieces Mover in:(sites Around (to) Orthogonal))) (define \"Side3\" (union (sites Side NW) (sites Side SW))) (define \"Side2\" (union (sites Side SE) (sites Side S))) (define \"Side1\" (union (sites Side NE) (sites Side N))) (game \"Defector Y\" (players 2) (equipment { (board (tri 8) use:Vertex) (piece \"Disc\" Each) (piece \"Counter\" Neutral maxState:2)}) (rules (play (if True (\"DefectorMove\") (priority (\"AddToEmpty\" (then (moveAgain))) (\"DefectorMove\")))) (end { (if (\"IsConnectedPlayer\") (result Mover Win))})))\n\n### Response:\n",
    "completion": "(define \"EdgesOfSide\" (intersection (sites Outer Edge) (forEach of:(difference #1 (sites Corners Vertex)) (sites Incident Edge of:Vertex at:(site))))) (define \"BoardColour\" (colour 215 203 170)) (define \"P2Colour\" (colour White)) (define \"P1Colour\" (colour DarkGreen)) (define \"IsConnectedPlayer\" (is Connected 3 {\"Side1\" \"Side2\" \"Side3\"})) (define \"DefectorMove\" (priority (move Add (to (sites Occupied by:Next) if:(< \"MoverLimit\" (count Pieces Next in:(sites Around (to) Orthogonal))) (apply (remove (to)))) (then (moveAgain))) (\"AddToEmpty\" ~))) (define \"AddToEmpty\" (move Add (to (sites Empty)) #1)) (define \"MoverLimit\" (count Pieces Mover in:(sites Around (to) Orthogonal))) (define \"Side3\" (union (sites Side NW) (sites Side SW))) (define \"Side2\" (union (sites Side SE) (sites Side S))) (define \"Side1\" (union (sites Side NE) (sites Side N))) (game \"Defector Y\" (players 2) (equipment { (board (tri 15) use:Vertex) (piece \"Disc\" Each) (piece \"Counter\" Neutral maxState:2)}) (rules (play (if True (\"DefectorMove\") (priority (\"AddToEmpty\" (then (moveAgain))) (\"DefectorMove\")))) (end { (if (\"IsConnectedPlayer\") (result Mover Win))})))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nTriangle-8 Board (36) -> Triangle-15 Board (120)",
    "_var_input": "(define \"EdgesOfSide\" (intersection (sites Outer Edge) (forEach of:(difference #1 (sites Corners Vertex)) (sites Incident Edge of:Vertex at:(site))))) (define \"BoardColour\" (colour 215 203 170)) (define \"P2Colour\" (colour White)) (define \"P1Colour\" (colour DarkGreen)) (define \"IsConnectedPlayer\" (is Connected 3 {\"Side1\" \"Side2\" \"Side3\"})) (define \"DefectorMove\" (priority (move Add (to (sites Occupied by:Next) if:(< \"MoverLimit\" (count Pieces Next in:(sites Around (to) Orthogonal))) (apply (remove (to)))) (then (moveAgain))) (\"AddToEmpty\" ~))) (define \"AddToEmpty\" (move Add (to (sites Empty)) #1)) (define \"MoverLimit\" (count Pieces Mover in:(sites Around (to) Orthogonal))) (define \"Side3\" (union (sites Side NW) (sites Side SW))) (define \"Side2\" (union (sites Side SE) (sites Side S))) (define \"Side1\" (union (sites Side NE) (sites Side N))) (game \"Defector Y\" (players 2) (equipment { (board (tri 8) use:Vertex) (piece \"Disc\" Each) (piece \"Counter\" Neutral maxState:2)}) (rules (play (if True (\"DefectorMove\") (priority (\"AddToEmpty\" (then (moveAgain))) (\"DefectorMove\")))) (end { (if (\"IsConnectedPlayer\") (result Mover Win))})))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n4x10 board. Forty counters in total. Play begins with one counter in each hole. One player then rearranges these counters however they like, as long as they remain on their side of the board and they remain on the board. They can arrange it so that they capture counters from the opponent's side according to the capture rules. The other player then does the same. Play begins with a player picking up counters from one of the holes with more than one on their side. Counters are sown in an anti-clockwise direction. When the last counter lands in an occupied hole, these counters are picked up and sowing continues until the last counter falls in an empty hole. When the last counter falls into an empty hole, either the turn ends or the player captures. Captures are only made from the inner row; if the corresponding hole in the opponent's inner row holds counters, these are captured; if there are also counters in the corresponding hole in the opponent's outer row, these are also captured. Play continues until one player has nothing left or one player has only single counters in their holes. If the player has no counters left, they have lost. If only single counters remain in a player's holes, they may now move single counters, but only into empty holes. Captures are made in the same way as before. \n\n### Response:\n",
    "completion": "(define \"OnlyHoleWithSingleCounters\" (all Sites (sites Mover \"Home\") if:(>= 1 (count at:(site))))) (define \"Columns\" 10) (game \"Makonn\" (players 2) (equipment { (mancalaBoard 4 \"Columns\" store:None { (track \"Track1\" \"0,E,N1,W\" loop:True P1) (track \"Track2\" \"20,E,N1,W\" loop:True P2)}) (regions \"Home\" P1 (sites Track \"Track1\")) (regions \"Home\" P2 (sites Track \"Track2\")) (regions \"Inner\" P1 (difference (sites Track \"Track1\") (sites Bottom))) (regions \"Inner\" P2 (difference (sites Track \"Track2\") (sites Top))) (piece \"Seed\" Shared)}) (rules (start (set Count 1 to:(union (sites P1 \"Home\") (sites P2 \"Home\")))) phases:{ (phase \"Rearrangement\" (play (or (move (from (sites Mover \"Home\") if:(is Occupied (from))) (to (sites Mover \"Home\") if:(!= (from) (to))) (then (and (if (and { (!= 1 (value Player Mover)) (is In (last To) (sites Mover \"Inner\")) (= 1 (count at:(last To)))}) (if (is Occupied (\"OppositePit\" (last To))) (and { (set Value Mover 1) (remove (\"OppositePit\" (last To))) (if (is Occupied (\"OppositeOuterPit\" (last To))) (remove (\"OppositeOuterPit\" (last To))))}))) (moveAgain)))) (move Pass))) (nextPhase Mover (was Pass) \"Sowing\")) (phase \"Sowing\" (play (move Select (from (if (\"SameTurn\") (sites {(var \"Replay\")}) (sites Mover \"Home\")) if:(if (\"SameTurn\") True (if (\"OnlyHoleWithSingleCounters\") (is Occupied (from)) (< 1 (count at:(from)))))) (then (sow \"Track\" owner:(mover) apply:(if (< 1 (count at:(to))) (and (set Var \"Replay\" (to)) (moveAgain)) (if (is Occupied (\"OppositePit\" (to))) (and (remove (\"OppositePit\" (to))) (if (is Occupied (\"OppositeOuterPit\" (to))) (remove (\"OppositeOuterPit\" (to))))))))))))} (end (if (all Sites (sites Next \"Home\") if:(= 0 (count at:(site)))) (result Next Loss)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "4x10 board. Forty counters in total. Play begins with one counter in each hole. One player then rearranges these counters however they like, as long as they remain on their side of the board and they remain on the board. They can arrange it so that they capture counters from the opponent's side according to the capture rules. The other player then does the same. Play begins with a player picking up counters from one of the holes with more than one on their side. Counters are sown in an anti-clockwise direction. When the last counter lands in an occupied hole, these counters are picked up and sowing continues until the last counter falls in an empty hole. When the last counter falls into an empty hole, either the turn ends or the player captures. Captures are only made from the inner row; if the corresponding hole in the opponent's inner row holds counters, these are captured; if there are also counters in the corresponding hole in the opponent's outer row, these are also captured. Play continues until one player has nothing left or one player has only single counters in their holes. If the player has no counters left, they have lost. If only single counters remain in a player's holes, they may now move single counters, but only into empty holes. Captures are made in the same way as before. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n2x6 board. Three counters per hole. Sowing occurs in an anti-clockwise direction when starting from the right three holes of a player's row, or in a clockwise direction when starting from the player's left three holes. When the final counter falls into an occupied hole, these are picked up and sowing continues, except when this hole is made to contain four counters, in which case these counters are captured and the player takes another turn. These captures may not be made on the first turn. When the final counter lands in an empty hole, the turn ends. Play continues until one player is without counters in their row. The opponent then captures the remaining counters in their row, and the player that has captured the most counters wins. \n\n### Response:\n",
    "completion": "(define \"PiecesOwnedBy\" (count Cell at:(handSite #1))) (define \"OneRowEmpty\" (or (all Sites (sites P1 \"Home\") if:(= 0 (count at:(site)))) (all Sites (sites P2 \"Home\") if:(= 0 (count at:(site)))))) (game \"Wa'ache Waledat\" (players 2) (equipment { (mancalaBoard 2 6 store:None { (track \"TrackCCW\" \"0,E,N,W\" loop:True) (track \"TrackCW\" \"5,W,N,E\" loop:True)}) (piece \"Seed\" Shared) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top)) (regions \"RightHome\" P1 (intersection (expand (sites Right) steps:2) (sites Bottom))) (regions \"RightHome\" P2 (intersection (expand (sites Right) steps:2) (sites Top))) (regions \"LeftHome\" P1 (intersection (expand (sites Left) steps:2) (sites Bottom))) (regions \"LeftHome\" P2 (intersection (expand (sites Left) steps:2) (sites Top))) (hand Each)}) (rules (start (set Count 3 to:(sites Track))) (play (or (if (or (>= 0 (var \"Direction\")) (= 1 (var \"Direction\"))) (move Select (from (if (and (\"SameTurn\") (= 1 (var \"ContinueSowing\"))) \"LastHoleSowed\" (sites Mover \"RightHome\")) if:(> (count at:(from)) 0)) (then (sow \"TrackCCW\" apply:(if (< 1 (count at:(to))) (and { (moveAgain) (set Var \"Direction\" 1) (set Var \"ContinueSowing\" 1) (if (and (= 4 (count at:(to))) (< 2 (count Turns))) (and (fromTo (from (to)) (to (handSite Mover)) count:4) (set Var \"ContinueSowing\" 0)))}) (set Var \"Direction\" 0)))))) (if (or (>= 0 (var \"Direction\")) (= 2 (var \"Direction\"))) (move Select (from (if (and (\"SameTurn\") (= 1 (var \"ContinueSowing\"))) \"LastHoleSowed\" (sites Mover \"LeftHome\")) if:(> (count at:(from)) 0)) (then (sow \"TrackCW\" apply:(if (< 1 (count at:(to))) (and { (moveAgain) (set Var \"Direction\" 2) (set Var \"ContinueSowing\" 1) (if (and (= 4 (count at:(to))) (< 2 (count Turns))) (and (fromTo (from (to)) (to (handSite Mover)) count:4) (set Var \"ContinueSowing\" 0)))}) (set Var \"Direction\" 0)))))) (then (if (\"OneRowEmpty\") (and (forEach Site (sites P1 \"Home\") (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2 \"Home\") (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))))))) (end (\"MancalaByScoreWhen\" (\"NoPieceOnBoard\")))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "2x6 board. Three counters per hole. Sowing occurs in an anti-clockwise direction when starting from the right three holes of a player's row, or in a clockwise direction when starting from the player's left three holes. When the final counter falls into an occupied hole, these are picked up and sowing continues, except when this hole is made to contain four counters, in which case these counters are captured and the player takes another turn. These captures may not be made on the first turn. When the final counter lands in an empty hole, the turn ends. Play continues until one player is without counters in their row. The opponent then captures the remaining counters in their row, and the player that has captured the most counters wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a triangle, with the apex intersecting with the midpoint of that side. There is a line from the apex to the midpoint of the triangle's base, and another interior triangle, connecting the base of the larger triangle with the midpoints of the sides of the larger triangle. One player plays as the Taisho (\\ \n\n### Response:\n",
    "completion": "(game \"Juroku Musashi\" (players 2) (equipment { (board (add (merge (scale 2 (square 5 diagonals:Alternating)) (shift 2 -2 (wedge 3))) vertices:{ {3 -2} {5 -2}} edges:{{25 31} {25 29} {27 29} {27 32}}) use:Vertex) (piece \"Marker\" P1 \"StepToEmpty\") (piece \"Marker\" P2 (or (\"HopCapture\") (\"StepToEmpty\")))}) (rules (start { (place \"Marker1\" (difference (sites Outer) (expand (sites Bottom)))) (place \"Marker2\" (ahead (centrePoint) N))}) (play (forEach Piece)) (end (\"NoMovesP2NoPiecesP1\"))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a triangle, with the apex intersecting with the midpoint of that side. There is a line from the apex to the midpoint of the triangle's base, and another interior triangle, connecting the base of the larger triangle with the midpoints of the sides of the larger triangle. One player plays as the Taisho (\\ "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(define \"IsPlayingPhase\" (= 1 (var))) (define \"BlackVC\" (or (\"IsSidesConnected\" S NW (sites Side NE)) (\"IsSidesConnected\" N SW (sites Side SE)))) (define \"WhiteVC\" (or { (\"IsSidesConnected\" S N) (\"IsSidesConnected\" SW NE) (\"IsSidesConnected\" SE NW)})) (define \"IsSidesConnected\" (is Connected {(sites Side #1) (sites Side #2) #3})) (game \"Unlur\" (players 2) (equipment { (board (hex 6)) (piece \"Disc\" Each)}) (rules phases:{ (phase \"Opening\" (play (or (move Add (piece (id \"Disc\" P2)) (to (intersection (sites Empty) (sites Inner)))) (move Pass (then (if (is Mover P1) (swap Players P1 P2 (then (note \"Player 1 is now Black. Player 2 is now White.\" to:All))) (note \"Player 1 remains White. Player 2 remains Black.\" to:All) (then (do (set NextPlayer (player 1)) next:(set Var 1)))))))) (nextPhase (\"IsPlayingPhase\") \"Playing\")) (phase \"Playing\" (play (move Add (to (sites Empty)))))} (end { (if (and {(\"IsPlayingPhase\") (= (id P1) (mover)) (\"BlackVC\") (not (\"WhiteVC\"))}) (result P1 Loss)) (if (and {(\"IsPlayingPhase\") (= (id P2) (mover)) (\"WhiteVC\") (not (\"BlackVC\"))}) (result P2 Loss)) (if (and {(\"IsPlayingPhase\") (= (id P1) (mover)) (\"WhiteVC\")}) (result P1 Win)) (if (and {(\"IsPlayingPhase\") (= (id P2) (mover)) (\"BlackVC\")}) (result P2 Win))})))\n\n### Response:\n",
    "completion": "This game is played on a hexagonal board made up of hexagonal squares, usually 6 squares per side, although other sizes are possible. Initially the board is empty and black pieces are placed in turns until one player passes. The player who passed becomes Black. The other player becomes White and takes the next turn. Play continues, with each player in turn placing pieces of their colour on unoccupied squares on the board. White wins if they manage to connect two opposite sides of the board. Black wins if they manage to connect three non-adjacent sides of the board. To avoid ties, if a player meets the opponent's goal with their pieces, they lose the game. The game is played on a board with 6 hexes per side. You cannot place stones on the edge in the opening phase.",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(define \"IsPlayingPhase\" (= 1 (var))) (define \"BlackVC\" (or (\"IsSidesConnected\" S NW (sites Side NE)) (\"IsSidesConnected\" N SW (sites Side SE)))) (define \"WhiteVC\" (or { (\"IsSidesConnected\" S N) (\"IsSidesConnected\" SW NE) (\"IsSidesConnected\" SE NW)})) (define \"IsSidesConnected\" (is Connected {(sites Side #1) (sites Side #2) #3})) (game \"Unlur\" (players 2) (equipment { (board (hex 6)) (piece \"Disc\" Each)}) (rules phases:{ (phase \"Opening\" (play (or (move Add (piece (id \"Disc\" P2)) (to (intersection (sites Empty) (sites Inner)))) (move Pass (then (if (is Mover P1) (swap Players P1 P2 (then (note \"Player 1 is now Black. Player 2 is now White.\" to:All))) (note \"Player 1 remains White. Player 2 remains Black.\" to:All) (then (do (set NextPlayer (player 1)) next:(set Var 1)))))))) (nextPhase (\"IsPlayingPhase\") \"Playing\")) (phase \"Playing\" (play (move Add (to (sites Empty)))))} (end { (if (and {(\"IsPlayingPhase\") (= (id P1) (mover)) (\"BlackVC\") (not (\"WhiteVC\"))}) (result P1 Loss)) (if (and {(\"IsPlayingPhase\") (= (id P2) (mover)) (\"WhiteVC\") (not (\"BlackVC\"))}) (result P2 Loss)) (if (and {(\"IsPlayingPhase\") (= (id P1) (mover)) (\"WhiteVC\")}) (result P1 Win)) (if (and {(\"IsPlayingPhase\") (= (id P2) (mover)) (\"BlackVC\")}) (result P2 Win))})))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThe rules are exactly the same as in Chess, except the Queen also has the ability to move as a knight. \n\n### Response:\n",
    "completion": "(define \"InitialPawnMove\" (if (is In (from) (sites Start (piece (what at:(from))))) (\"DoubleStepForwardToEmpty\" \"SetEnPassantLocation\"))) (define \"EnPassant\" (move Step (directions {FR FL}) (to if:\"InLocationEnPassant\") (then (remove (ahead (last To) Backward))))) (define \"InLocationEnPassant\" (and (is Pending) (= (to) (value Pending)))) (define \"SetEnPassantLocation\" (then (set Pending (ahead (last To) Backward)))) (define \"Castling\" (if (and (\"HasNeverMoved\" \"King\") (not (\"IsInCheck\" \"King\" Mover))) (or (if (and (\"HasNeverMoved\" \"RookLeft\") (can Move (\"CastleRook\" \"RookLeft\" E 3 (is Empty (to))))) \"BigCastling\") (if (and (\"HasNeverMoved\" \"RookRight\") (can Move (\"CastleRook\" \"RookRight\" W 2 (is Empty (to))))) \"SmallCastling\")))) (define \"BigCastling\" (\"DecideToCastle\" \"King\" W 2 \"KingNotCheckedAndToEmpty\" (then (\"CastleRook\" \"RookLeft\" E 3 True)))) (define \"SmallCastling\" (\"DecideToCastle\" \"King\" E 2 \"KingNotCheckedAndToEmpty\" (then (\"CastleRook\" \"RookRight\" W 2 True)))) (define \"CastleRook\" (slide (from (mapEntry #1 (mover))) #2 (between (exact #3) if:#4) (to if:True (apply (\"PieceHasMoved\" (from)))))) (define \"DecideToCastle\" (move Slide (from (mapEntry #1 (mover))) #2 (between (exact #3) if:#4) (to if:True (apply (\"PieceHasMoved\" (from)))) #5)) (define \"KingNotCheckedAndToEmpty\" (and (is Empty (to)) (not (\"IsInCheck\" \"King\" Mover at:(to))))) (define \"RememberPieceHasMoved\" (then (if (= (state at:(last To)) 1) (\"PieceHasMoved\" (last To))))) (define \"PieceHasMoved\" (set State at:#1 0)) (define \"HasNeverMoved\" (= (state at:(mapEntry #1 (mover))) 1)) (game \"Amazon Chess\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (\"ChessPawn\" \"Pawn\" (or \"InitialPawnMove\" \"EnPassant\") (then (and (\"ReplayInMovingOn\" (sites Mover \"Promotion\")) (set Counter)))) (\"ChessRook\" \"Rook\" (then (set Counter)) (\"RememberPieceHasMoved\")) (\"ChessKing\" \"King\" (then (set Counter)) (\"RememberPieceHasMoved\")) (\"ChessBishop\" \"Bishop\" (then (set Counter))) (\"ChessKnight\" \"Knight\" (then (set Counter))) (piece \"Queen\" Each (or (\"SlideCapture\" ~ ~ (then (set Counter))) (\"LeapCapture\" \"KnightWalk\" (then (set Counter))))) (map \"King\" {(pair 1 \"E1\") (pair 2 \"E8\")}) (map \"RookLeft\" {(pair 1 \"A1\") (pair 2 \"A8\")}) (map \"RookRight\" {(pair 1 \"H1\") (pair 2 \"H8\")}) (regions \"Promotion\" P1 (sites Top)) (regions \"Promotion\" P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (sites Row 1)) (place \"Pawn2\" (sites Row 6)) (place \"Rook1\" {\"A1\" \"H1\"} state:1) (place \"Knight1\" {\"B1\" \"G1\"}) (place \"Bishop1\" {\"C1\" \"F1\"}) (place \"Queen1\" coord:\"D1\") (place \"King1\" coord:\"E1\" state:1) (place \"Rook2\" {\"A8\" \"H8\"} state:1) (place \"Knight2\" {\"B8\" \"G8\"}) (place \"Bishop2\" {\"C8\" \"F8\"}) (place \"Queen2\" coord:\"D8\") (place \"King2\" coord:\"E8\" state:1)}) (play (if \"SameTurn\" (move Promote (last To) (piece {\"Queen\" \"Knight\" \"Bishop\" \"Rook\"}) Mover) (do (or (forEach Piece) (\"Castling\")) ifAfterwards:(not (\"IsInCheck\" \"King\" Mover))))) (end { (\"Checkmate\" \"King\") (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))})))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "The rules are exactly the same as in Chess, except the Queen also has the ability to move as a knight. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayed on a square Alquerque board with 9x9 intersecting lines with diagonals. Each player has 40 pieces. Pieces are placed on the intersections of the lines, and move forward along the lines to an adjacent unoccupied intersection. Once pieces reach the opposite side of the board from their starting position at the end of their turn, they are promoted and can move in any direction and over any distance. Opponent's pieces are captured by jumping them. Captures are obligatory if possible. If a player does not capture when they are supposed to, the opponent may remove that piece immediately and then play as normal. The player who captures all of their opponent's pieces or blocks them from being able to move wins. \n\n### Response:\n",
    "completion": "(define \"ShouldCapturedButMoved\" (and (is In (last From) (\"SitesWithPossibleCaptureInPreviousTurn\")) (is In (last From) (sites Empty)))) (define \"HuffOnePieceOf\" (move Select (from #1 if:(is Occupied (from))) (then (and { (remove (last To)) (moveAgain) (set Value Prev 0)})))) (define \"SitesWithPossibleCaptureInPreviousTurn\" (sites Pending)) (define \"RememberSiteWithPossibleCapture\" (set Pending (sites From (or (forEach Piece \"Disc\" (\"HopDisc\")) (forEach Piece \"DiscDouble\" (\"HopCaptureDistance\")))))) (define \"DidNotCaptured\" (= (value Player Prev) 1)) (define \"HasNotCaptured\" (set Value Mover 1)) (define \"HasCaptured\" (set Value Mover 0)) (define \"HopDiscDouble\" (\"HopCaptureDistance\" ~ ~ ~ (then (\"HasCaptured\")))) (define \"HopDisc\" (\"HopCapture\" ~ ~ (then (and (\"PromoteIfReach\" (sites Next) \"DiscDouble\") (\"HasCaptured\"))))) (game \"Zamma\" (\"TwoPlayersNorthSouth\") (equipment { (\"AlquerqueBoard\" 9 9) (piece \"Disc\" Each (or (\"HopDisc\") (\"StepToEmpty\" Forwards (then (\"HasNotCaptured\"))) (then (\"PromoteIfReach\" (sites Next) \"DiscDouble\")))) (piece \"DiscDouble\" Each (or (\"HopDiscDouble\") (move Slide (then (\"HasNotCaptured\"))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (\"BeforeAfterCentreSetup\" \"Disc1\" \"Disc2\") (play (or (if (\"DidNotCaptured\") (or (if (\"ShouldCapturedButMoved\") (\"HuffOnePieceOf\" (last To))) (\"HuffOnePieceOf\" (\"SitesWithPossibleCaptureInPreviousTurn\")))) (do (\"RememberSiteWithPossibleCapture\") next:(forEach Piece)))) (end (if (no Moves Mover) (result Next Win)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Played on a square Alquerque board with 9x9 intersecting lines with diagonals. Each player has 40 pieces. Pieces are placed on the intersections of the lines, and move forward along the lines to an adjacent unoccupied intersection. Once pieces reach the opposite side of the board from their starting position at the end of their turn, they are promoted and can move in any direction and over any distance. Opponent's pieces are captured by jumping them. Captures are obligatory if possible. If a player does not capture when they are supposed to, the opponent may remove that piece immediately and then play as normal. The player who captures all of their opponent's pieces or blocks them from being able to move wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nIf the next player has no legal moves, the mover is winning. This ludemeplex can be used only in an ending condition.\n\n### Response:\n",
    "completion": "(define \"BlockWin\" (if (no Moves Next) (result Mover Win)))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "If the next player has no legal moves, the mover is winning. This ludemeplex can be used only in an ending condition."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Fifteen pieces per player. The starting position is as such, number the points from the origin of each player's track: point six: five pieces; point 8: three pieces; point 13: five pieces; point 24: two pieces. Two dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When a player's piece lands on a spot occupied by a single piece belonging to the opponent, the opponent's piece is sent back to the quadrant in which that player started with two pieces. Players bear off their pieces at the end of their track. The first player to bear off all their pieces wins. \n\n### Response:\n",
    "completion": "(define \"GoBack\" (if (and (!= (to) (regionSite (sites #1 \"StartQuadrant\") index:0)) (not (\"IsFriendAt\" (regionSite (sites #1 \"StartQuadrant\") index:0)))) (regionSite (sites #1 \"StartQuadrant\") index:0) (if (and (!= (to) (regionSite (sites #1 \"StartQuadrant\") index:1)) (not (\"IsFriendAt\" (regionSite (sites #1 \"StartQuadrant\") index:1)))) (regionSite (sites #1 \"StartQuadrant\") index:1) (if (and (!= (to) (regionSite (sites #1 \"StartQuadrant\") index:2)) (not (\"IsFriendAt\" (regionSite (sites #1 \"StartQuadrant\") index:2)))) (regionSite (sites #1 \"StartQuadrant\") index:2) (if (and (!= (to) (regionSite (sites #1 \"StartQuadrant\") index:3)) (not (\"IsFriendAt\" (regionSite (sites #1 \"StartQuadrant\") index:3)))) (regionSite (sites #1 \"StartQuadrant\") index:3) (if (and (!= (to) (regionSite (sites #1 \"StartQuadrant\") index:4)) (not (\"IsFriendAt\" (regionSite (sites #1 \"StartQuadrant\") index:4)))) (regionSite (sites #1 \"StartQuadrant\") index:4) (if (and (!= (to) (regionSite (sites #1 \"StartQuadrant\") index:5)) (not (\"IsFriendAt\" (regionSite (sites #1 \"StartQuadrant\") index:5)))) (regionSite (sites #1 \"StartQuadrant\") index:5) (if (and (!= (to) (regionSite (sites #1 \"StartQuadrant\") index:6)) (not (\"IsFriendAt\" (regionSite (sites #1 \"StartQuadrant\") index:6)))) (regionSite (sites #1 \"StartQuadrant\") index:6) Off)))))))) (define \"NextSiteFrom\" (\"NextSiteOnTrack\" #2 from:#1)) (game \"Todas Tablas\" (players 2) (equipment { (\"TableBoard\" \"TableTracksOpposite2\") (dice d:6 num:2) (piece \"Disc\" Each (forEach Die if:(\"DieNotUsed\") (if (\"IsOffBoard\" (\"NextSiteFrom\" (from) (pips))) (move Remove (from)) (move (from (from)) (to (\"NextSiteFrom\" (from) (pips)) if:(\"NoEnemyOrOnlyOne\" (to)) (\"HittingCapture\" (\"GoBack\" Next))))) (then (\"ReplayNotAllDiceUsed\")))) (regions \"StartQuadrant\" P1 (sites {6..11})) (regions \"StartQuadrant\" P2 (sites {18..23}))}) (rules (start { (place Stack \"Disc1\" 6 count:5) (place Stack \"Disc1\" 4 count:3) (place Stack \"Disc1\" 12 count:5) (place Stack \"Disc1\" 23 count:2) (place Stack \"Disc2\" 18 count:5) (place Stack \"Disc2\" 16 count:3) (place Stack \"Disc2\" 0 count:5) (place Stack \"Disc2\" 11 count:2)}) (play (\"RollEachNewTurnMove\" (forEach Piece))) (end (\"EscapeWin\"))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Fifteen pieces per player. The starting position is as such, number the points from the origin of each player's track: point six: five pieces; point 8: three pieces; point 13: five pieces; point 24: two pieces. Two dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When a player's piece lands on a spot occupied by a single piece belonging to the opponent, the opponent's piece is sent back to the quadrant in which that player started with two pieces. Players bear off their pieces at the end of their track. The first player to bear off all their pieces wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nWhat does the following global Ludii definition do?\n\n### Input:\n(define \"StepStackToEmpty\" (move Step #1 (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True #2))\n\n### Response:\n",
    "completion": "Defines a step move of a full stack to all the directions specified (adjacent by default) to an empty site.",
    "_var_instruction": "What does the following global Ludii definition do?",
    "_var_input": "(define \"StepStackToEmpty\" (move Step #1 (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True #2))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nThe game has 2 players. -> The game has 3 players.\n\n### Input:\n(define \"MoveBankor\" (move (from (\"WhereBankor\") level:(\"LevelBankor\")) (to (\"BankorOnTrack\" \"Track\" (\"ThrowValue\"))) (then (and (if (!= (mover) \"StateBankor\") (set State at:(\"WhereBankor\") level:(\"LevelBankor\") (mover))) (if (= (last To) (\"Center\")) (forEach Site (sites Track \"Track\" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (remove (site) level:(level))))) (forEach Site (sites Track \"Track\" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (last To))))))))))) (define \"Center\" 0) (define \"StateBankor\" (state at:(\"WhereBankor\") level:(\"LevelBankor\"))) (define \"LevelBankor\" (where Level \"Bankor\" Neutral at:(\"WhereBankor\"))) (define \"WhereBankor\" (where \"Bankor\" Neutral)) (define \"BankorPhaseDone\" (or (= (\"WhereBankor\") (\"Center\")) (and (is Occupied (\"Center\")) (>= 1 (count Sites in:(difference (sites Occupied by:All) (\"WhereBankor\"))))))) (define \"BankorOnTrack\" (\"NextSiteOnTrack\" #2 from:(\"WhereBankor\") #1)) (define \"SiteToMoveOnTrack\" (\"NextSiteOnTrack\" #2 #1)) (define \"Throw1\" (= (\"ThrowValue\") 1)) (define \"ThrowValue\" (mapEntry \"Throw\" (count Pips))) (game \"Sik\" (players 2) (equipment { (board (spiral turns:5 sites:86) { (track \"Track\" {85..0} directed:True)} use:Vertex) (\"StickDice\" 4) (map \"Throw\" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)}) (piece \"Stick\" Each (move (from (from) level:(level) if:(or (= 1 (state at:(from) level:(level))) (\"Throw1\"))) (to (\"SiteToMoveOnTrack\" \"Track\" (\"ThrowValue\")) if:True) (then (if (!= 1 (state at:(last To) level:(last LevelTo))) (set State at:(last To) level:(last LevelTo) 1))))) (piece \"Bankor\" Neutral)}) (rules (start { (place Stack items:{\"Stick2\" \"Stick1\"} 85) (place Stack \"Bankor0\" 85)}) (play (\"RollMove\" (if (= (\"Center\") (where \"Stick\" Mover)) (if (< (value Player Mover) 2) (move Pass (then (set Value Mover (+ 1 (value Player Mover))))) (if (or (= (mover) (\"StateBankor\")) (= 0 (\"StateBankor\"))) (if (!= 0 (\"ThrowValue\")) (\"MoveBankor\")))) (if (!= 0 (\"ThrowValue\")) (forEach Piece))))) (end { (forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(\"BankorPhaseDone\") (result Player Win))})))\n\n### Response:\n",
    "completion": "(define \"MoveBankor\" (move (from (\"WhereBankor\") level:(\"LevelBankor\")) (to (\"BankorOnTrack\" \"Track\" (\"ThrowValue\"))) (then (and (if (!= (mover) \"StateBankor\") (set State at:(\"WhereBankor\") level:(\"LevelBankor\") (mover))) (if (= (last To) (\"Center\")) (forEach Site (sites Track \"Track\" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (remove (site) level:(level))))) (forEach Site (sites Track \"Track\" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (last To))))))))))) (define \"Center\" 0) (define \"StateBankor\" (state at:(\"WhereBankor\") level:(\"LevelBankor\"))) (define \"LevelBankor\" (where Level \"Bankor\" Neutral at:(\"WhereBankor\"))) (define \"WhereBankor\" (where \"Bankor\" Neutral)) (define \"BankorPhaseDone\" (or (= (\"WhereBankor\") (\"Center\")) (and (is Occupied (\"Center\")) (>= 1 (count Sites in:(difference (sites Occupied by:All) (\"WhereBankor\"))))))) (define \"BankorOnTrack\" (\"NextSiteOnTrack\" #2 from:(\"WhereBankor\") #1)) (define \"SiteToMoveOnTrack\" (\"NextSiteOnTrack\" #2 #1)) (define \"Throw1\" (= (\"ThrowValue\") 1)) (define \"ThrowValue\" (mapEntry \"Throw\" (count Pips))) (game \"Sik\" (players 3) (equipment { (board (spiral turns:5 sites:86) { (track \"Track\" {85..0} directed:True)} use:Vertex) (\"StickDice\" 4) (map \"Throw\" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)}) (piece \"Stick\" Each (move (from (from) level:(level) if:(or (= 1 (state at:(from) level:(level))) (\"Throw1\"))) (to (\"SiteToMoveOnTrack\" \"Track\" (\"ThrowValue\")) if:True) (then (if (!= 1 (state at:(last To) level:(last LevelTo))) (set State at:(last To) level:(last LevelTo) 1))))) (piece \"Bankor\" Neutral)}) (rules (start { (place Stack items:{\"Stick3\" \"Stick2\" \"Stick1\"} 85) (place Stack \"Bankor0\" 85)}) (play (\"RollMove\" (if (= (\"Center\") (where \"Stick\" Mover)) (if (< (value Player Mover) 2) (move Pass (then (set Value Mover (+ 1 (value Player Mover))))) (if (or (= (mover) (\"StateBankor\")) (= 0 (\"StateBankor\"))) (if (!= 0 (\"ThrowValue\")) (\"MoveBankor\")))) (if (!= 0 (\"ThrowValue\")) (forEach Piece))))) (end { (forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(\"BankorPhaseDone\") (result Player Win))})))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nThe game has 2 players. -> The game has 3 players.",
    "_var_input": "(define \"MoveBankor\" (move (from (\"WhereBankor\") level:(\"LevelBankor\")) (to (\"BankorOnTrack\" \"Track\" (\"ThrowValue\"))) (then (and (if (!= (mover) \"StateBankor\") (set State at:(\"WhereBankor\") level:(\"LevelBankor\") (mover))) (if (= (last To) (\"Center\")) (forEach Site (sites Track \"Track\" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (remove (site) level:(level))))) (forEach Site (sites Track \"Track\" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (last To))))))))))) (define \"Center\" 0) (define \"StateBankor\" (state at:(\"WhereBankor\") level:(\"LevelBankor\"))) (define \"LevelBankor\" (where Level \"Bankor\" Neutral at:(\"WhereBankor\"))) (define \"WhereBankor\" (where \"Bankor\" Neutral)) (define \"BankorPhaseDone\" (or (= (\"WhereBankor\") (\"Center\")) (and (is Occupied (\"Center\")) (>= 1 (count Sites in:(difference (sites Occupied by:All) (\"WhereBankor\"))))))) (define \"BankorOnTrack\" (\"NextSiteOnTrack\" #2 from:(\"WhereBankor\") #1)) (define \"SiteToMoveOnTrack\" (\"NextSiteOnTrack\" #2 #1)) (define \"Throw1\" (= (\"ThrowValue\") 1)) (define \"ThrowValue\" (mapEntry \"Throw\" (count Pips))) (game \"Sik\" (players 2) (equipment { (board (spiral turns:5 sites:86) { (track \"Track\" {85..0} directed:True)} use:Vertex) (\"StickDice\" 4) (map \"Throw\" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)}) (piece \"Stick\" Each (move (from (from) level:(level) if:(or (= 1 (state at:(from) level:(level))) (\"Throw1\"))) (to (\"SiteToMoveOnTrack\" \"Track\" (\"ThrowValue\")) if:True) (then (if (!= 1 (state at:(last To) level:(last LevelTo))) (set State at:(last To) level:(last LevelTo) 1))))) (piece \"Bankor\" Neutral)}) (rules (start { (place Stack items:{\"Stick2\" \"Stick1\"} 85) (place Stack \"Bankor0\" 85)}) (play (\"RollMove\" (if (= (\"Center\") (where \"Stick\" Mover)) (if (< (value Player Mover) 2) (move Pass (then (set Value Mover (+ 1 (value Player Mover))))) (if (or (= (mover) (\"StateBankor\")) (= 0 (\"StateBankor\"))) (if (!= 0 (\"ThrowValue\")) (\"MoveBankor\")))) (if (!= 0 (\"ThrowValue\")) (forEach Piece))))) (end { (forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(\"BankorPhaseDone\") (result Player Win))})))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nDefines a regular start board (example: Kaooa).\n\n### Response:\n",
    "completion": "(define \"StarBoard\" (board (splitCrossings (regular Star #1)) use:Vertex))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Defines a regular start board (example: Kaooa)."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(game \"Tule Paid\" (players 2) (equipment { (board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece \"Marker\" Each (\"StepToEmpty\" ~ (then (\"ReplayIfLine3\"))))}) (rules (start (place \"Marker\" \"Hand\" count:12)) phases:{ (phase \"Placement\" (play (if \"SameTurn\" \"RemoveAnyEnemyPiece\" (move (from (handSite Mover)) (to (sites Empty)) (then (\"ReplayIfLine3\"))))) (nextPhase Mover (\"HandEmpty\" Mover) \"Movement\")) (phase \"Movement\" (play (if \"SameTurn\" \"RemoveAnyEnemyPiece\" (forEach Piece))))} (end (\"CaptureAll\" Next))))\n\n### Response:\n",
    "completion": "Three concentric squares, with lines connecting the diagonals and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on an empty spot on the board. When a player places three pieces in a row along one of the lines on the board, they remove one of the pieces belonging to the opponent. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines. The first player to capture all of the opponent's pieces wins. ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(game \"Tule Paid\" (players 2) (equipment { (board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece \"Marker\" Each (\"StepToEmpty\" ~ (then (\"ReplayIfLine3\"))))}) (rules (start (place \"Marker\" \"Hand\" count:12)) phases:{ (phase \"Placement\" (play (if \"SameTurn\" \"RemoveAnyEnemyPiece\" (move (from (handSite Mover)) (to (sites Empty)) (then (\"ReplayIfLine3\"))))) (nextPhase Mover (\"HandEmpty\" Mover) \"Movement\")) (phase \"Movement\" (play (if \"SameTurn\" \"RemoveAnyEnemyPiece\" (forEach Piece))))} (end (\"CaptureAll\" Next))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n3x3 intersecting lines, with diagonals. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. Once all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. The first player to place three pieces in a line wins. \n\n### Response:\n",
    "completion": "(game \"Liu Tsi\" (players 2) (equipment { (\"AlquerqueBoard\" 3 3) (hand Each) (piece \"Marker\" Each \"StepToEmpty\")}) (rules (start (place \"Marker\" \"Hand\" count:3)) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (\"HandEmpty\" P2) \"Movement\")) (\"PhaseMovePiece\" \"Movement\")} (end (\"Line3Win\"))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "3x3 intersecting lines, with diagonals. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. Once all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. The first player to place three pieces in a line wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nDefines the most popular backgammon tracks in using the hands of the players.\n\n### Response:\n",
    "completion": "(define \"BackgammonTracksWithHands\" { (track \"Track1\" {26 12..7 5..0 13..18 20..25 #1} P1 directed:True) (track \"Track2\" {27 25..20 18..13 0..5 7..12 #1} P2 directed:True)})",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Defines the most popular backgammon tracks in using the hands of the players."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThree concentric squares, with the midpoints of their sides connected with lines. Twelve pieces per player. Players take turns placing one of their pieces on an empty point on the board. The first player to make three in a row obtains the privilege of starting the next phase after all of the stones are placed; if no one makes three in a row the last player to place a stone begins the next phase. Ones all of the stones are placed, the player who has the right to begin the next phase removes any one of the opponent's stones, and the opponent does the same with one of the player's pieces. Then, players alternate turns moving one of their pieces to an empty adjacent space. When a player place three of their pieces in a row, they remove one of the opponent's pieces. If a player moves in such a way that the opponent cannot move, the player must make an extra move to allow the opponent a place to play. A player cannot capture an opponent's piece when this extra move is made. The player who captures all but two of the opponent's pieces wins. Games are usually played in sequence, starting with the winner of the previous game, with the first player to win five games in a row being the winner.\n         \n\n### Response:\n",
    "completion": "(define \"ResetGame\" (and { (remove (sites Occupied by:All)) (add (piece (id \"Marker\" P1)) (to (handSite P1)) count:12) (add (piece (id \"Marker\" P2)) (to (handSite P2)) count:12)})) (define \"RemoveEnemyPiece\" (move Remove (sites Occupied by:Next container:\"Board\") #1)) (define \"IfLine3MoveAgain\" (then (if (and (\"NewTurn\") (is Line 3)) (moveAgain) (if (no Moves Next) (and (moveAgain) (set Pending)))))) (define \"SetPlayerSecondPhase\" (and (if (and (< (var) 1) (is Line 3)) (set Var #1)) (if (and (\"HandEmpty\" P1) (\"HandEmpty\" P2)) (if (< (\"PlayerSecondPhase\") 1) (moveAgain) (set NextPlayer (player (\"PlayerSecondPhase\"))))))) (define \"PlayerSecondPhase\" (var)) (game \"Shah\" (players 2) (equipment { (\"NineMensMorrisBoard\") (piece \"Marker\" Each (\"StepToEmpty\" ~ \"IfLine3MoveAgain\")) (hand Each)}) (rules (start (place \"Marker\" \"Hand\" count:12)) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (sites Empty)) (then (\"SetPlayerSecondPhase\" (mover))))) (nextPhase (and (\"HandEmpty\" P1) (\"HandEmpty\" P2)) \"Remove\")) (phase \"Remove\" (play (\"RemoveEnemyPiece\")) (nextPhase Mover \"Move\")) (phase \"Move\" (play (if (and (not (is Pending)) \"SameTurn\") (\"RemoveEnemyPiece\" (then (if (no Moves Next) (and (moveAgain) (set Pending))))) (if (is Pending) (do (forEach Piece (\"StepToEmpty\")) ifAfterwards:(can Move (forEach Piece Next))) (forEach Piece)) (then (if (= 2 (count Pieces P1)) (addScore P2 1 (then (if (!= (score P2) 5) (\"ResetGame\")))) (if (= 2 (count Pieces P2)) (addScore P1 1 (then (if (!= (score P1) 5) (\"ResetGame\"))))))))) (nextPhase (= 0 (count Sites in:(sites Occupied by:All container:\"Board\"))) \"Placement\"))} (end (if (= (score Mover) 5) (result Mover Win)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Three concentric squares, with the midpoints of their sides connected with lines. Twelve pieces per player. Players take turns placing one of their pieces on an empty point on the board. The first player to make three in a row obtains the privilege of starting the next phase after all of the stones are placed; if no one makes three in a row the last player to place a stone begins the next phase. Ones all of the stones are placed, the player who has the right to begin the next phase removes any one of the opponent's stones, and the opponent does the same with one of the player's pieces. Then, players alternate turns moving one of their pieces to an empty adjacent space. When a player place three of their pieces in a row, they remove one of the opponent's pieces. If a player moves in such a way that the opponent cannot move, the player must make an extra move to allow the opponent a place to play. A player cannot capture an opponent's piece when this extra move is made. The player who captures all but two of the opponent's pieces wins. Games are usually played in sequence, starting with the winner of the previous game, with the first player to win five games in a row being the winner.\n         "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nThe game is played on a 4x4 board. -> The game is played on a 5x5 board.\n\n### Input:\n(define \"Dim\" 4) (define \"HopSequence\" (\"Hop\" #1 (then (if (can Move (\"Hop\" (last To))) (moveAgain))))) (define \"Hop\" (move Hop (from #1) (between if:(is Occupied (between))) (to if:(and (\"IsEmptyAndNotVisited\" (to)) (or (not (\"FromIsOnTheRegionToFill\" #1)) (\"ToIsOnTheRegionToFill\" (to))))) #2)) (define \"ToIsOnTheRegionToFill\" (is In #1 (sites (player (mapEntry (mover)))))) (define \"FromIsOnTheRegionToFill\" (is In #1 (sites (player (mapEntry (mover)))))) (game \"Halma\" (players 2) (equipment { (board (square (\"Dim\"))) (piece \"Counter\" Each) (regions \"Home\" P1 (difference (expand (intersection (sites Bottom) (sites Right)) steps:(+ 1 (/ (\"Dim\") 4)) Orthogonal) (sites { (ahead (coord row:0 column:(- (\"Dim\") 1)) steps:(+ 1 (/ (\"Dim\") 4)) N) (ahead (coord row:0 column:(- (\"Dim\") 1)) steps:(+ 1 (/ (\"Dim\") 4)) W)}))) (regions \"Home\" P2 (difference (expand (intersection (sites Top) (sites Left)) steps:(+ 1 (/ (\"Dim\") 4)) Orthogonal) (sites { (ahead (coord row:(- (\"Dim\") 1) column:0) steps:(+ 1 (/ (\"Dim\") 4)) E) (ahead (coord row:(- (\"Dim\") 1) column:0) steps:(+ 1 (/ (\"Dim\") 4)) S)}))) (map {(pair P1 P2) (pair P2 P1)})}) (rules (start { (place \"Counter1\" (sites P1)) (place \"Counter2\" (sites P2))}) phases:{ (phase \"Movement\" (play (forEach Piece (or (\"HopSequence\" (from)) (move Step (to if:(and (is Empty (to)) (or (not (\"FromIsOnTheRegionToFill\" (from))) (\"ToIsOnTheRegionToFill\" (to))))))))) (nextPhase (is Mover (next)) \"MultiJump\")) (phase \"MultiJump\" (play (or (\"HopSequence\" (last To)) (move Pass))) (nextPhase (not (is Mover (next))) \"Movement\"))} (end (\"FillWin\" (sites (player (mapEntry (mover))))))))\n\n### Response:\n",
    "completion": "(define \"Dim\" 5) (define \"HopSequence\" (\"Hop\" #1 (then (if (can Move (\"Hop\" (last To))) (moveAgain))))) (define \"Hop\" (move Hop (from #1) (between if:(is Occupied (between))) (to if:(and (\"IsEmptyAndNotVisited\" (to)) (or (not (\"FromIsOnTheRegionToFill\" #1)) (\"ToIsOnTheRegionToFill\" (to))))) #2)) (define \"ToIsOnTheRegionToFill\" (is In #1 (sites (player (mapEntry (mover)))))) (define \"FromIsOnTheRegionToFill\" (is In #1 (sites (player (mapEntry (mover)))))) (game \"Halma\" (players 2) (equipment { (board (square (\"Dim\"))) (piece \"Counter\" Each) (regions \"Home\" P1 (difference (expand (intersection (sites Bottom) (sites Right)) steps:(+ 1 (/ (\"Dim\") 4)) Orthogonal) (sites { (ahead (coord row:0 column:(- (\"Dim\") 1)) steps:(+ 1 (/ (\"Dim\") 4)) N) (ahead (coord row:0 column:(- (\"Dim\") 1)) steps:(+ 1 (/ (\"Dim\") 4)) W)}))) (regions \"Home\" P2 (difference (expand (intersection (sites Top) (sites Left)) steps:(+ 1 (/ (\"Dim\") 4)) Orthogonal) (sites { (ahead (coord row:(- (\"Dim\") 1) column:0) steps:(+ 1 (/ (\"Dim\") 4)) E) (ahead (coord row:(- (\"Dim\") 1) column:0) steps:(+ 1 (/ (\"Dim\") 4)) S)}))) (map {(pair P1 P2) (pair P2 P1)})}) (rules (start { (place \"Counter1\" (sites P1)) (place \"Counter2\" (sites P2))}) phases:{ (phase \"Movement\" (play (forEach Piece (or (\"HopSequence\" (from)) (move Step (to if:(and (is Empty (to)) (or (not (\"FromIsOnTheRegionToFill\" (from))) (\"ToIsOnTheRegionToFill\" (to))))))))) (nextPhase (is Mover (next)) \"MultiJump\")) (phase \"MultiJump\" (play (or (\"HopSequence\" (last To)) (move Pass))) (nextPhase (not (is Mover (next))) \"Movement\"))} (end (\"FillWin\" (sites (player (mapEntry (mover))))))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nThe game is played on a 4x4 board. -> The game is played on a 5x5 board.",
    "_var_input": "(define \"Dim\" 4) (define \"HopSequence\" (\"Hop\" #1 (then (if (can Move (\"Hop\" (last To))) (moveAgain))))) (define \"Hop\" (move Hop (from #1) (between if:(is Occupied (between))) (to if:(and (\"IsEmptyAndNotVisited\" (to)) (or (not (\"FromIsOnTheRegionToFill\" #1)) (\"ToIsOnTheRegionToFill\" (to))))) #2)) (define \"ToIsOnTheRegionToFill\" (is In #1 (sites (player (mapEntry (mover)))))) (define \"FromIsOnTheRegionToFill\" (is In #1 (sites (player (mapEntry (mover)))))) (game \"Halma\" (players 2) (equipment { (board (square (\"Dim\"))) (piece \"Counter\" Each) (regions \"Home\" P1 (difference (expand (intersection (sites Bottom) (sites Right)) steps:(+ 1 (/ (\"Dim\") 4)) Orthogonal) (sites { (ahead (coord row:0 column:(- (\"Dim\") 1)) steps:(+ 1 (/ (\"Dim\") 4)) N) (ahead (coord row:0 column:(- (\"Dim\") 1)) steps:(+ 1 (/ (\"Dim\") 4)) W)}))) (regions \"Home\" P2 (difference (expand (intersection (sites Top) (sites Left)) steps:(+ 1 (/ (\"Dim\") 4)) Orthogonal) (sites { (ahead (coord row:(- (\"Dim\") 1) column:0) steps:(+ 1 (/ (\"Dim\") 4)) E) (ahead (coord row:(- (\"Dim\") 1) column:0) steps:(+ 1 (/ (\"Dim\") 4)) S)}))) (map {(pair P1 P2) (pair P2 P1)})}) (rules (start { (place \"Counter1\" (sites P1)) (place \"Counter2\" (sites P2))}) phases:{ (phase \"Movement\" (play (forEach Piece (or (\"HopSequence\" (from)) (move Step (to if:(and (is Empty (to)) (or (not (\"FromIsOnTheRegionToFill\" (from))) (\"ToIsOnTheRegionToFill\" (to))))))))) (nextPhase (is Mover (next)) \"MultiJump\")) (phase \"MultiJump\" (play (or (\"HopSequence\" (last To)) (move Pass))) (nextPhase (not (is Mover (next))) \"Movement\"))} (end (\"FillWin\" (sites (player (mapEntry (mover))))))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nYour goal in Gobblet Junior is to place three of your pieces in a horizontal, vertical or diagonal row. Your pieces can stack on top of each other, and they start the game nested, off the board. On a turn, you either play one exposed piece from your three off-the-board piles or move one piece on the board to any other spot on the board where it fits. A larger piece can cover any smaller piece.\n            \n        Your memory is tested as you try to remember which color one of your larger pieces is covering before you move it. As soon as a player has three like-colored pieces in a row, he wins. \n\n### Response:\n",
    "completion": "(game \"Gobblet Gobblers\" (players 2) (equipment { (board (square 3)) (piece \"Disc1\" Each) (piece \"Disc2\" Each) (piece \"Disc3\" Each) (hand Each size:3)}) (rules (start { (place Stack \"Disc11\" (handSite P1) count:3) (place Stack \"Disc12\" (handSite P2) count:3) (place Stack \"Disc21\" (handSite P1 1) count:3) (place Stack \"Disc22\" (handSite P2 1) count:3) (place Stack \"Disc31\" (handSite P1 2) count:3) (place Stack \"Disc32\" (handSite P2 2) count:3)}) (play (or (\"MoveToEmptyOrOccupiedByLargerPiece\" (sites Hand Mover) if:(is Occupied (from))) (\"MoveToEmptyOrOccupiedByLargerPiece\" (sites Occupied by:Mover top:True)))) (end (forEach Player if:(is Line 3 Player top:True) (result Player Win)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Your goal in Gobblet Junior is to place three of your pieces in a horizontal, vertical or diagonal row. Your pieces can stack on top of each other, and they start the game nested, off the board. On a turn, you either play one exposed piece from your three off-the-board piles or move one piece on the board to any other spot on the board where it fits. A larger piece can cover any smaller piece.\n            \n        Your memory is tested as you try to remember which color one of your larger pieces is covering before you move it. As soon as a player has three like-colored pieces in a row, he wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nDefines a step move to all the orthogonal directions to an empty site.\n\n### Response:\n",
    "completion": "(define \"StepOrthogonalToEmpty\" (move Step Orthogonal (to if:(is Empty (to)))))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Defines a step move to all the orthogonal directions to an empty site."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlay occurs on a 3x3 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, losing is they make three in a row of their colour. \n\n### Response:\n",
    "completion": "(game \"Tic-Tac-Toe Misere\" (players 2) (equipment { (board (square 3)) (piece \"Disc\" P1) (piece \"Cross\" P2)}) (rules (play (move Add (to (sites Empty)))) (end (if (is Line 3) (result Next Win)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Play occurs on a 3x3 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, losing is they make three in a row of their colour. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThree concentric squares, with lines connecting the diagonals and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing one of their pieces on one of the empty intersections of the board. If a player places three of their stones in a straight line, the player may remove one of the opponent's pieces. When all of the pieces have been placed, the players alternate turns moving one of their pieces to an empty adjacent point along the lines of the board. When a player is reduced to three pieces, they may move one of their stone to any empty space on the board. The player who reduces their opponent to two pieces wins. \n\n### Response:\n",
    "completion": "(define \"RemoveEnemyPiece\" (if (can Move (\"RemoveAnyEnemyPieceNotInLine3\" Orthogonal)) (\"RemoveAnyEnemyPieceNotInLine3\" Orthogonal) (\"RemoveAnyEnemyPiece\"))) (game \"Tsoro Yemutwelve\" (players 2) (equipment { (board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece \"Marker\" Each (\"StepToEmpty\" ~ (then (\"ReplayIfLine3\" Orthogonal exact:True))))}) (rules (start (place \"Marker\" \"Hand\" count:12)) phases:{ (phase \"Placement\" (play (if \"SameTurn\" \"RemoveEnemyPiece\" (move (from (handSite Mover)) (to (sites Empty)) (then (\"ReplayIfLine3\" Orthogonal exact:True))))) (nextPhase Mover (\"HandEmpty\" Mover) \"Movement\")) (phase \"Movement\" (play (if \"SameTurn\" \"RemoveEnemyPiece\" (if (> (count Pieces Mover) 3) (forEach Piece) (move (from (sites Occupied by:Mover)) (to (sites Empty)))))))} (end (\"HavingLessPiecesLoss\" Next 2))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Three concentric squares, with lines connecting the diagonals and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing one of their pieces on one of the empty intersections of the board. If a player places three of their stones in a straight line, the player may remove one of the opponent's pieces. When all of the pieces have been placed, the players alternate turns moving one of their pieces to an empty adjacent point along the lines of the board. When a player is reduced to three pieces, they may move one of their stone to any empty space on the board. The player who reduces their opponent to two pieces wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nMOVING\n            Each player moves one ship each turn. A ship moves any number of empty squares in a straight line, either vertically, horizontally, or diagonally (that is, like a chess queen). However, a ship may never end its turn in its home port.\n            \n            DESTROYING SHIPS\n            Two opposing ships \\ \n\n### Response:\n",
    "completion": "(define \"CanMoveANewShip\" (not (all Sites (difference (expand origin:(mapEntry \"Port\" P1)) (mapEntry \"Port\" Mover)) if:(is Occupied (site))))) (define \"CapturingPortNotAttacked\" (> 3 (count Sites in:(forEach (sites LineOfSight at:(if (is Mover P1) (mapEntry \"Port\" P2) (mapEntry \"Port\" P1))) if:(if (is Mover P1) (= (who at:(site)) P1) (= (who at:(site)) P2)))))) (define \"AttackByAtLeast3\" (<= 3 (count Sites in:(forEach (sites LineOfSight at:(site)) if:(= (who at:(site)) Mover))))) (game \"Archimedes\" (players 2) (equipment { (board (square 8)) (piece \"Ball\" Each (move Slide (between if:(and (is Empty (between)) (!= (between) (mapEntry \"Port\" Mover)))))) (map \"Port\" {(pair P1 \"H8\") (pair P2 \"A1\")}) (hand Each)}) (rules (start { (place \"Ball1\" (difference (expand origin:(mapEntry \"Port\" P1) steps:4 Orthogonal) (sites {\"D8\" \"H4\" \"H8\"}))) (place \"Ball2\" (difference (expand origin:(mapEntry \"Port\" P2) steps:4 Orthogonal) (sites {\"A5\" \"A1\" \"E1\"})))}) (play (if (\"SameTurn\") (move Slide (from (mapEntry \"Port\" Mover))) (or (forEach Piece (then (forEach Site (sites Occupied by:Next) (if (\"AttackByAtLeast3\") (fromTo (from (site)) (to (handSite Next))))))) (if (and { (is Occupied (handSite Mover)) (is Empty (mapEntry \"Port\" Mover)) (\"CanMoveANewShip\")}) (move (from (handSite Mover)) (to (mapEntry \"Port\" Mover)) (then (moveAgain))))))) (end (if (and (\"IsFriendAt\" (if (is Mover P1) (mapEntry \"Port\" P2) (mapEntry \"Port\" P1))) (\"CapturingPortNotAttacked\")) (result Mover Win)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "MOVING\n            Each player moves one ship each turn. A ship moves any number of empty squares in a straight line, either vertically, horizontally, or diagonally (that is, like a chess queen). However, a ship may never end its turn in its home port.\n            \n            DESTROYING SHIPS\n            Two opposing ships \\ "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nSix or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. A circle is drawn in the central space; this is the \\ The game has 6 players.\n\n### Response:\n",
    "completion": "(define \"CapturedPiecesFollowCapturingPiece\" (forEach Level (last From) FromTop (if (\"CapturedPiece\" (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To)))))) (define \"RebirthCapturingPiece\" (add (piece (id \"Stick\" Mover)) (to (handSite Mover)))) (define \"RemoveCapturedPieces\" (forEach Level (last From) FromTop (if (\"CapturedPiece\" (state at:(last From) level:(level))) (remove (last From) level:(level))))) (define \"CaptureMove\" (forEach Level (last To) FromTop (and (if (\"IsEnemyAt\" (last To) level:(level)) (\"SetCapturePiece\" at:(last To) level:(level))) (if (\"IsFriendAt\" (last To) level:(level)) (\"SetCapturingPiece\" at:(last To) level:(level)))))) (define \"AtLeastAnEnemyPieceThere\" (is In #1 (sites Occupied by:Enemy top:False))) (define \"FreePiece\" (= 0 #1)) (define \"CapturedPiece\" (= 2 #1)) (define \"CapturingPiece\" (= 1 #1)) (define \"UnsetCapturingPieces\" (forEach Level (last From) FromTop (if (\"IsFriendAt\" (last From) level:(level)) (\"UnsetCapturingPiece\" at:(last From) level:(level))))) (define \"UnsetCapturingPiece\" (set State #1 #2 0)) (define \"SetCapturingPiece\" (set State #1 #2 1)) (define \"SetCapturePiece\" (set State #1 #2 2)) (define \"NoPieceOnBoard\" (< (count Pieces Mover in:(sites Board)) 1)) (define \"FireSites\" (sites Centre)) (define \"ThrowValue\" (count Pips)) (game \"A K'aak'il\" (players 6) (equipment { (board (rectangle 1 20) { (track \"Track1\" {19 0..18} P1 directed:True) (track \"Track2\" {20 0..18} P2 directed:True) (track \"Track3\" {21 0..18} P3 directed:True) (track \"Track4\" {22 18..0} P4 directed:True) (track \"Track5\" {23 18..0} P5 directed:True) (track \"Track6\" {24 18..0} P6 directed:True) (track \"CaptureTrack1\" {18..0} P1 directed:True) (track \"CaptureTrack2\" {18..0} P2 directed:True) (track \"CaptureTrack3\" {18..0} P3 directed:True) (track \"CaptureTrack4\" {0..18} P4 directed:True) (track \"CaptureTrack5\" {0..18} P5 directed:True) (track \"CaptureTrack6\" {0..18} P6 directed:True)} use:Edge) (regions \"AllSites\" (sites Board Vertex)) (piece \"Stick\" Each (forEach Value (values Remembered \"Throws\") (or (if (\"FreePiece\" (state at:(from) level:(level))) (if (\"IsOffBoard\" (\"NextSiteOnTrack\" (value) from:(from) \"Track\")) (move (from (from) level:(level)) (to (handSite Mover) (apply (forget Value \"Throws\" (value))))) (move (from (from) level:(level) if:(if (is In (from) (sites Hand Mover)) (\"NoPieceOnBoard\") True)) (to (\"NextSiteOnTrack\" (value) from:(from) \"Track\") (apply (forget Value \"Throws\" (value)))) (then (if (\"AtLeastAnEnemyPieceThere\" (last To)) (\"CaptureMove\")))))) (if (\"CapturingPiece\" (state at:(from) level:(level))) (if (\"IsOffBoard\" (\"NextSiteOnTrack\" (value) from:(from) \"CaptureTrack\")) (do (forget Value \"Throws\" (value)) next:(move Remove (from) level:(level) (then (and { (\"UnsetCapturingPieces\") (\"RemoveCapturedPieces\") (\"RebirthCapturingPiece\")})))) (move (from (from) level:(level)) (to (\"NextSiteOnTrack\" (value) from:(from) \"CaptureTrack\") (apply (forget Value \"Throws\" (value)))) (then (and (\"CapturedPiecesFollowCapturingPiece\") (\"UnsetCapturingPieces\"))))))))) (\"StickDice\" 4) (hand Each)}) (rules (start { (set Team 1 {P1 P2 P3}) (set Team 2 {P4 P5 P6}) (place Stack \"Stick1\" (handSite P1) count:5) (place Stack \"Stick2\" (handSite P2) count:5) (place Stack \"Stick3\" (handSite P3) count:5) (place Stack \"Stick4\" (handSite P4) count:5) (place Stack \"Stick5\" (handSite P5) count:5) (place Stack \"Stick6\" (handSite P6) count:5)}) phases:{ (phase \"ThrowPhase\" (play (\"RollMove\" (move Pass (then (if (not (no Pieces Mover)) (and { (if (!= 0 (\"ThrowValue\")) (do (remember Value \"Throws\" (\"ThrowValue\")) ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece))))) (moveAgain) (if (\"SameTurn\") (set Pending))})))))) (nextPhase (is Pending) \"MovePhase\")) (phase \"MovePhase\" (play (or (forEach Piece) (forEach Piece container:(mover)) (then (and (if (< 0 (size Array (values Remembered \"Throws\"))) (moveAgain)) (forEach Site (\"FireSites\") (if (is Occupied (site)) (forEach Level (site) FromTop (remove (site) level:(level))))))))) (nextPhase (= 0 (size Array (values Remembered \"Throws\"))) \"ThrowPhase\"))} (end (\"CaptureAllTeam\"))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. A circle is drawn in the central space; this is the \\ The game has 6 players."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n8x8 board. The pieces move as follows, with the number per player: King (x1): moves one space orthogonally or diagonally; Counselor (x1): One square diagonally, but may move two spaces forward orthogonally on the first move, jumping over the Soldier in front of it on the first move of the game; Rook (x2): Any number of spaces orthogonally; Elephant (x2): Two squares diagonally, jumping over the first, cannot capture another Elephant; Horse (x2): Moves as a chess knight. Soldier (x8): Moves one space forward orthogonally; one space forward diagonally to capture. The Soldier in front of the Counselor may jump to the space in front of the Counselor when it has used its special move on the first turn, this must be done as the second move of the game, i.e. on the next turn after the Counselor had made its special move. No en passant. Soldiers promote to Counselor when reaching the eighth rank. No castling. Stalemate results in a win for player causing it. The player who checkmates the king wins.\n         \n\n### Response:\n",
    "completion": "(game \"Rumi Shatranj\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (hand Each size:5) (\"ChessKing\" \"King_noCross\") (\"ChessRook\" \"Rook\") (piece \"Elephant\" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (\"IsEnemyAt\" (to)) (not (\"IsPieceAt\" \"Elephant\" Next (to))))) (apply (remove (to)))))) (\"ChessKnight\" \"Knight\") (\"ChessPawn\" \"Pawn\" ~ (then (\"ReplayInMovingOn\" (sites Mover \"Promotion\")))) (piece \"Ferz_noCross\" Each (\"StepToNotFriend\" Diagonal)) (regions \"Promotion\" P1 (sites Top)) (regions \"Promotion\" P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (sites Row 1)) (place \"Pawn2\" (sites Row 6)) (place \"Rook1\" {\"A1\" \"H1\"}) (place \"Knight1\" {\"B1\" \"G1\"}) (place \"Elephant1\" {\"C1\" \"F1\"}) (place \"Ferz_noCross1\" coord:\"D1\") (place \"King_noCross1\" coord:\"E1\") (place \"Rook2\" {\"A8\" \"H8\"}) (place \"Knight2\" {\"B8\" \"G8\"}) (place \"Elephant2\" {\"C8\" \"F8\"}) (place \"Ferz_noCross2\" coord:\"D8\") (place \"King_noCross2\" coord:\"E8\")}) phases:{ (phase \"OpeningCounselor\" (play (forEach Piece \"Ferz_noCross\" (move Hop Forward (between if:True) (to if:(is Empty (to)) (apply (remove (to))))))) (nextPhase Mover \"OpeningSoldier\")) (phase \"OpeningSoldier\" (play (forEach Piece \"Pawn\" (if (is In (from) (sites {\"D2\" \"D7\"})) (move Hop Forward (between if:True) (to if:(is Empty (to)) (apply (remove (to)))))))) (nextPhase Mover \"Playing\")) (phase \"Playing\" (play (if \"SameTurn\" (move Promote (last To) (piece \"Ferz_noCross\") Mover) (do (forEach Piece) ifAfterwards:(not (\"IsInCheck\" \"King_noCross\" Mover))))))} (end { (\"Checkmate\" \"King_noCross\") (\"BlockWin\")})))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "8x8 board. The pieces move as follows, with the number per player: King (x1): moves one space orthogonally or diagonally; Counselor (x1): One square diagonally, but may move two spaces forward orthogonally on the first move, jumping over the Soldier in front of it on the first move of the game; Rook (x2): Any number of spaces orthogonally; Elephant (x2): Two squares diagonally, jumping over the first, cannot capture another Elephant; Horse (x2): Moves as a chess knight. Soldier (x8): Moves one space forward orthogonally; one space forward diagonally to capture. The Soldier in front of the Counselor may jump to the space in front of the Counselor when it has used its special move on the first turn, this must be done as the second move of the game, i.e. on the next turn after the Counselor had made its special move. No en passant. Soldiers promote to Counselor when reaching the eighth rank. No castling. Stalemate results in a win for player causing it. The player who checkmates the king wins.\n         "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n8x8 board. Sixteen pieces per player. The pieces begin on the first and third rank or squares with respect to each player. Pieces move orthogonally any distance. Pieces are captured when surrounded on both sides by an enemy piece. Enemy pieces may also be taken if a piece moves into a space such that the enemy pieces are on either side of it. The goal is to capture all of the enemy's pieces. \n\n### Response:\n",
    "completion": "(game \"Maak Yek\" (players 2) (equipment { (board (square 8)) (piece \"Marker\" Each (move Slide Orthogonal (then (and (\"InterveneCapture\" Orthogonal) (\"CustodialCapture\" Orthogonal)))))}) (rules (start { (place \"Marker1\" (union (sites Row 0) (sites Row 2))) (place \"Marker2\" (union (sites Row 5) (sites Row 7)))}) (play (forEach Piece)) (end (\"CaptureAll\" Next))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "8x8 board. Sixteen pieces per player. The pieces begin on the first and third rank or squares with respect to each player. Pieces move orthogonally any distance. Pieces are captured when surrounded on both sides by an enemy piece. Enemy pieces may also be taken if a piece moves into a space such that the enemy pieces are on either side of it. The goal is to capture all of the enemy's pieces. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nThe players play on LastEdgeR-B version. -> The players play on LastEdgeR-G-B version.\n\n### Input:\n(game \"LastEdge\" (players 2) (equipment { (board (graph vertices:{ {0 0} {0 1} {0 2} {0 3} {0 4} {1 0} {1 1} {1 2} {1 3} {1 4} {2 0} {2 1} {2 2} {2 3} {2 4} {3 0} {3 1} {3 2} {3 3} {3 4} {4 0} {4 1} {4 2} {4 3} {4 4}} edges:{ {0 1} {0 5} {1 6} {1 2} {2 7} {2 3} {3 8} {3 4} {4 9} {5 6} {5 10} {6 11} {6 7} {7 12} {7 8} {8 13} {8 9} {9 14} {10 11} {11 12} {12 13} {13 14} {10 15} {11 16} {12 17} {13 18} {14 19} {15 16} {15 20} {16 21} {20 21} {16 17} {17 22} {21 22} {17 18} {18 23} {22 23} {18 19} {19 24} {23 24}}) use:Vertex) (piece \"Disc\" Each) (piece \"Marker\" Shared)}) (rules (start { (set P1 Edge (sites {0..9 34 35 36})) (set P2 Edge (difference (sites Board Edge) (sites {0..9 34 35 36})))}) (play (forEach Site (sites Board) (if (< 0 (count Sites in:(sites Incident Edge of:Vertex at:(to) Mover))) (move Add (to (intersection (sites Empty) (sites {(to)}))) (then (forEach Site (sites Incident Edge of:Vertex at:(last To)) (remove Edge (to)))))))) (end (\"BlockWin\"))))\n\n### Response:\n",
    "completion": "(game \"LastEdge\" (players 2) (equipment { (board (graph vertices:{ {0 0} {0 1} {0 2} {0 3} {0 4} {1 0} {1 1} {1 2} {1 3} {1 4} {2 0} {2 1} {2 2} {2 3} {2 4} {3 0} {3 1} {3 2} {3 3} {3 4} {4 0} {4 1} {4 2} {4 3} {4 4}} edges:{ {0 1} {0 5} {1 6} {1 2} {2 7} {2 3} {3 8} {3 4} {4 9} {5 6} {5 10} {6 11} {6 7} {7 12} {7 8} {8 13} {8 9} {9 14} {10 11} {11 12} {12 13} {13 14} {10 15} {11 16} {12 17} {13 18} {14 19} {15 16} {15 20} {16 21} {20 21} {16 17} {17 22} {21 22} {17 18} {18 23} {22 23} {18 19} {19 24} {23 24}}) use:Vertex) (piece \"Disc\" Each) (piece \"Marker\" Shared)}) (rules (start { (set P1 Edge (sites {0..5 13..20})) (set P2 Edge (sites {9..12 23..30})) (set Shared Edge (difference (sites Board Edge) (union (sites {0..5 13..20}) (sites {9..12 23..30}))))}) (play (forEach Site (sites Board) (if (> (count Sites in:(difference (sites Incident Edge of:Vertex at:(to) All) (sites Incident Edge of:Vertex at:(to) Next))) 0) (move Add (to (intersection (sites Empty) (sites {(to)}))) (then (forEach Site (sites Incident Edge of:Vertex at:(last To)) (remove Edge (to)))))))) (end (\"BlockWin\"))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nThe players play on LastEdgeR-B version. -> The players play on LastEdgeR-G-B version.",
    "_var_input": "(game \"LastEdge\" (players 2) (equipment { (board (graph vertices:{ {0 0} {0 1} {0 2} {0 3} {0 4} {1 0} {1 1} {1 2} {1 3} {1 4} {2 0} {2 1} {2 2} {2 3} {2 4} {3 0} {3 1} {3 2} {3 3} {3 4} {4 0} {4 1} {4 2} {4 3} {4 4}} edges:{ {0 1} {0 5} {1 6} {1 2} {2 7} {2 3} {3 8} {3 4} {4 9} {5 6} {5 10} {6 11} {6 7} {7 12} {7 8} {8 13} {8 9} {9 14} {10 11} {11 12} {12 13} {13 14} {10 15} {11 16} {12 17} {13 18} {14 19} {15 16} {15 20} {16 21} {20 21} {16 17} {17 22} {21 22} {17 18} {18 23} {22 23} {18 19} {19 24} {23 24}}) use:Vertex) (piece \"Disc\" Each) (piece \"Marker\" Shared)}) (rules (start { (set P1 Edge (sites {0..9 34 35 36})) (set P2 Edge (difference (sites Board Edge) (sites {0..9 34 35 36})))}) (play (forEach Site (sites Board) (if (< 0 (count Sites in:(sites Incident Edge of:Vertex at:(to) Mover))) (move Add (to (intersection (sites Empty) (sites {(to)}))) (then (forEach Site (sites Incident Edge of:Vertex at:(last To)) (remove Edge (to)))))))) (end (\"BlockWin\"))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(define \"AllSitesNoMoreThanOne\" (all Sites (sites Mover \"Home\") if:(>= 1 (count at:(site))))) (define \"NextHole\" (\"NextSiteOnTrack\" #2 from:#1 \"Track\")) (define \"NoPiece\" (all Sites (sites Player \"Home\") if:(= 0 (count at:(site))))) (define \"Columns\" 10) (game \"Nsolo\" (players 2) (equipment { (mancalaBoard 4 \"Columns\" store:None { (track \"Track1\" \"0,E,N1,W\" loop:True P1) (track \"Track2\" \"20,E,N1,W\" loop:True P2)}) (regions \"Home\" P1 (sites Track \"Track1\")) (regions \"Home\" P2 (sites Track \"Track2\")) (regions \"Inner\" P1 (difference (sites Track \"Track1\") (sites Bottom))) (regions \"Inner\" P2 (difference (sites Track \"Track2\") (sites Top))) (piece \"Seed\" Shared)}) (rules (start (set Count 2 to:(union { (sites Bottom) (sites Top) (difference (sites P1 \"Inner\") (sites Right)) (difference (sites P2 \"Inner\") (sites Left))}))) (play (if (and (\"SameTurn\") (= (var \"Replay\") Undefined)) (move Remove (sites Next \"Home\")) (if (\"AllSitesNoMoreThanOne\") (move Select (from (sites Mover \"Home\") if:(and (is Occupied (from)) (is Empty (\"NextHole\" (from) 1)))) (then (sow \"Track\" owner:(mover)))) (move Select (from (if (\"SameTurn\") (sites {(var \"Replay\")}) (sites Mover \"Home\")) if:(> (count at:(from)) 1)) (then (sow \"Track\" owner:(mover) apply:(if (< 1 (count at:(to))) (if (and (is In (to) (sites Mover \"Inner\")) (is Occupied (\"OppositePit\" (to)))) (and (remove (\"OppositePit\" (to))) (if (is Occupied (\"OppositeOuterPit\" (to))) (and { (moveAgain) (set Var \"Replay\" Undefined) (remove (\"OppositeOuterPit\" (to)))}))) (and (moveAgain) (set Var \"Replay\" (to))))))))))) (end (forEach NonMover if:(\"NoPiece\") (result Player Loss)))))\n\n### Response:\n",
    "completion": "4x10-20 board, with even numbers. Two counters in each hole, except the rightmost hole in the inner row of each player, which has zero. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from one other hole on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 10 holes.",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(define \"AllSitesNoMoreThanOne\" (all Sites (sites Mover \"Home\") if:(>= 1 (count at:(site))))) (define \"NextHole\" (\"NextSiteOnTrack\" #2 from:#1 \"Track\")) (define \"NoPiece\" (all Sites (sites Player \"Home\") if:(= 0 (count at:(site))))) (define \"Columns\" 10) (game \"Nsolo\" (players 2) (equipment { (mancalaBoard 4 \"Columns\" store:None { (track \"Track1\" \"0,E,N1,W\" loop:True P1) (track \"Track2\" \"20,E,N1,W\" loop:True P2)}) (regions \"Home\" P1 (sites Track \"Track1\")) (regions \"Home\" P2 (sites Track \"Track2\")) (regions \"Inner\" P1 (difference (sites Track \"Track1\") (sites Bottom))) (regions \"Inner\" P2 (difference (sites Track \"Track2\") (sites Top))) (piece \"Seed\" Shared)}) (rules (start (set Count 2 to:(union { (sites Bottom) (sites Top) (difference (sites P1 \"Inner\") (sites Right)) (difference (sites P2 \"Inner\") (sites Left))}))) (play (if (and (\"SameTurn\") (= (var \"Replay\") Undefined)) (move Remove (sites Next \"Home\")) (if (\"AllSitesNoMoreThanOne\") (move Select (from (sites Mover \"Home\") if:(and (is Occupied (from)) (is Empty (\"NextHole\" (from) 1)))) (then (sow \"Track\" owner:(mover)))) (move Select (from (if (\"SameTurn\") (sites {(var \"Replay\")}) (sites Mover \"Home\")) if:(> (count at:(from)) 1)) (then (sow \"Track\" owner:(mover) apply:(if (< 1 (count at:(to))) (if (and (is In (to) (sites Mover \"Inner\")) (is Occupied (\"OppositePit\" (to)))) (and (remove (\"OppositePit\" (to))) (if (is Occupied (\"OppositeOuterPit\" (to))) (and { (moveAgain) (set Var \"Replay\" Undefined) (remove (\"OppositeOuterPit\" (to)))}))) (and (moveAgain) (set Var \"Replay\" (to))))))))))) (end (forEach NonMover if:(\"NoPiece\") (result Player Loss)))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThe game is played on a board with ten round pits arranged in a circle. Each player owns the semicircle closest to him. The game requires ten seeds and one standard six-faced die. At the start of the game, each pit contains one seed.\n            \n            During their turn, a player rolls a die. He then chooses one of his nonempty pits to sow. They take one seed from the sown pit, and move it counterclockwise according to the die value rolled. Then, they must roll to move each remaining seed from the sown pit. The turn only ends once the sown pit is empty. So, for example, if a player chooses to sow a pit with 4 seeds after his initial roll, 3 additional rolls will be needed.\n            \n        A player wins when all ten seeds are on their part of the board at the end of their turn. \n\n### Response:\n",
    "completion": "(define \"NextHoleFrom\" (trackSite Move from:#1 steps:#2)) (game \"Lelac\" (players 2) (equipment { (board (concentric {0 10}) (track \"Track\" {0..9} loop:True) use:Vertex) (piece \"Square\" Shared) (dice d:6 num:1) (regions P1 (expand (sites Bottom) steps:2)) (regions P2 (expand (sites Top) steps:2))}) (rules (start (set Count 1 to:(sites Board))) (play (\"RollMove\" (move (from (if (\"SameTurn\") (sites {(last From)}) (forEach (sites Mover) if:(is Occupied (site))))) (to (\"NextHoleFrom\" (from) (count Pips))) (then (if (is Occupied (last From)) (moveAgain)))))) (end (forEach Player if:(all Sites (sites Player) if:(and (is Next Player) (is Empty (site)))) (result Player Loss)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "The game is played on a board with ten round pits arranged in a circle. Each player owns the semicircle closest to him. The game requires ten seeds and one standard six-faced die. At the start of the game, each pit contains one seed.\n            \n            During their turn, a player rolls a die. He then chooses one of his nonempty pits to sow. They take one seed from the sown pit, and move it counterclockwise according to the die value rolled. Then, they must roll to move each remaining seed from the sown pit. The turn only ends once the sown pit is empty. So, for example, if a player chooses to sow a pit with 4 seeds after his initial roll, 3 additional rolls will be needed.\n            \n        A player wins when all ten seeds are on their part of the board at the end of their turn. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(game \"Orissa Tiger Game (One Tiger)\" (players 2) (equipment { (board (rotate 180 (\"AlquerqueGraphWithBottomTriangle\")) use:Vertex) (piece \"Tiger\" P1 (or (\"StepToEmpty\") (\"HopCapture\"))) (piece \"Goat\" P2 (\"StepToEmpty\"))}) (rules (start { (place \"Tiger1\" (sites {\"C6\"})) (place \"Goat2\" (union (expand (sites Bottom)) (sites {\"A3\" \"E3\"})))}) (play (forEach Piece)) (end (\"NoMovesP1NoPiecesP2\"))))\n\n### Response:\n",
    "completion": "5x5 lines, intersecting to form a square. Diagonals are drawn in the four quadrants of the board. One triangle, its apex intersecting the main board at the midpoint of one side. The base of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. One player plays as the tiger, placed on the central point of the triangle, and the other plays as twelve goats, which begin on the first two rows of points opposite the triangle and on the outer two points in the third row. The tiger moves first. Pieces move to an empty adjacent spot along the lines on the board. The tiger alone may capture a goat by hopping over it to an empty spot immediately opposite a goat. The tiger wins by capturing all the goats; the goats win by blocking the tiger from being able to move. ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(game \"Orissa Tiger Game (One Tiger)\" (players 2) (equipment { (board (rotate 180 (\"AlquerqueGraphWithBottomTriangle\")) use:Vertex) (piece \"Tiger\" P1 (or (\"StepToEmpty\") (\"HopCapture\"))) (piece \"Goat\" P2 (\"StepToEmpty\"))}) (rules (start { (place \"Tiger1\" (sites {\"C6\"})) (place \"Goat2\" (union (expand (sites Bottom)) (sites {\"A3\" \"E3\"})))}) (play (forEach Piece)) (end (\"NoMovesP1NoPiecesP2\"))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nIn standard chess, the captured piece is removed from the board and the capturing piece takes its place. In atomic chess, a capture causes an \\ \n\n### Response:\n",
    "completion": "(define \"CaptureForwardDiagonal\" (\"StepToEnemy\" (directions {FR FL}) (then (and { (remove (last To)) (\"Boom\" (last To))})))) (define \"EnPassant\" (move Step (directions {FR FL}) (to if:\"InLocationEnPassant\") (then (and { (remove (ahead (last To) Backward)) (remove (last To)) (\"Boom\" (last To))})))) (define \"InLocationEnPassant\" (and (is Pending) (= (to) (value Pending)))) (define \"SetEnPassantLocation\" (then (set Pending (ahead (last To) Backward)))) (define \"Castling\" (if (and (\"HasNeverMoved\" \"King\") (not (\"IsInCheck\" \"King\" Mover))) (or (if (and (\"HasNeverMoved\" \"RookLeft\") (can Move (\"CastleRook\" \"RookLeft\" E 3 (is Empty (to))))) \"BigCastling\") (if (and (\"HasNeverMoved\" \"RookRight\") (can Move (\"CastleRook\" \"RookRight\" W 2 (is Empty (to))))) \"SmallCastling\")))) (define \"BigCastling\" (\"DecideToCastle\" \"King\" W 2 \"KingNotCheckedAndToEmpty\" (then (\"CastleRook\" \"RookLeft\" E 3 True)))) (define \"SmallCastling\" (\"DecideToCastle\" \"King\" E 2 \"KingNotCheckedAndToEmpty\" (then (\"CastleRook\" \"RookRight\" W 2 True)))) (define \"CastleRook\" (slide (from (mapEntry #1 (mover))) #2 (between (exact #3) if:#4) (to if:True (apply (\"PieceHasMoved\" (from)))))) (define \"DecideToCastle\" (move Slide (from (mapEntry #1 (mover))) #2 (between (exact #3) if:#4) (to if:True (apply (\"PieceHasMoved\" (from)))) #5)) (define \"KingNotCheckedAndToEmpty\" (and (is Empty (to)) (not (\"IsInCheck\" \"King\" Mover at:(to))))) (define \"CaptureToPieceAndResetCounter\" (apply (if (\"IsEnemyAt\" (to)) (and { (remove (to)) (\"Boom\" (to)) (set Counter)})))) (define \"RememberPieceHasMoved\" (then (if (= (state at:(last To)) 1) (\"PieceHasMoved\" (last To))))) (define \"PieceHasMoved\" (set State at:#1 0)) (define \"HasNeverMoved\" (= (state at:(mapEntry #1 (mover))) 1)) (define \"NextCanNotMove\" (not (can Move (do (forEach Piece Next) ifAfterwards:(not (\"IsInCheck\" \"King\" Next)))))) (define \"Boom\" (forEach Site (sites Around #1 includeSelf:False) (if (and { (is Occupied (site)) (and (not (\"IsPieceAt\" \"Pawn\" P1 (site))) (not (\"IsPieceAt\" \"Pawn\" P2 (site))))}) (remove (site))))) (game \"Atomic Chess\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (piece \"Pawn\" Each (or { (if (is In (from) (sites Start (piece (what at:(from))))) (\"DoubleStepForwardToEmpty\" \"SetEnPassantLocation\")) \"StepForwardToEmpty\" \"CaptureForwardDiagonal\" \"EnPassant\"} (then (and (if (is In (last To) (sites Mover \"Promotion\")) (moveAgain)) (set Counter))))) (piece \"Rook\" Each (move Slide Orthogonal (to if:(\"IsEnemyAt\" (to)) \"CaptureToPieceAndResetCounter\") (\"RememberPieceHasMoved\"))) (piece \"King\" Each (move Step (to if:(is Empty (to))) (\"RememberPieceHasMoved\"))) (piece \"Bishop\" Each (move Slide Diagonal (to if:(\"IsEnemyAt\" (to)) (\"CaptureToPieceAndResetCounter\")))) (piece \"Knight\" Each (move Leap \"KnightWalk\" (to if:(not (\"IsFriendAt\" (to))) (\"CaptureToPieceAndResetCounter\")))) (piece \"Queen\" Each (move Slide (to if:(\"IsEnemyAt\" (to)) (\"CaptureToPieceAndResetCounter\")))) (map \"King\" {(pair 1 \"E1\") (pair 2 \"E8\")}) (map \"RookLeft\" {(pair 1 \"A1\") (pair 2 \"A8\")}) (map \"RookRight\" {(pair 1 \"H1\") (pair 2 \"H8\")}) (regions \"Promotion\" P1 (sites Top)) (regions \"Promotion\" P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (sites Row 1)) (place \"Pawn2\" (sites Row 6)) (place \"Rook1\" {\"A1\" \"H1\"} state:1) (place \"Knight1\" {\"B1\" \"G1\"}) (place \"Bishop1\" {\"C1\" \"F1\"}) (place \"Queen1\" coord:\"D1\") (place \"King1\" coord:\"E1\" state:1) (place \"Rook2\" {\"A8\" \"H8\"} state:1) (place \"Knight2\" {\"B8\" \"G8\"}) (place \"Bishop2\" {\"C8\" \"F8\"}) (place \"Queen2\" coord:\"D8\") (place \"King2\" coord:\"E8\" state:1)}) (play (if \"SameTurn\" (move Promote (last To) (piece {\"Queen\" \"Knight\" \"Bishop\" \"Rook\"}) Mover) (do (or (forEach Piece) (\"Castling\")) ifAfterwards:(and (not (\"IsInCheck\" \"King\" Mover)) (\"IsNotOffBoard\" (where \"King\" Mover)))))) (end { (if (or (and (\"IsInCheck\" \"King\" Next) (\"NextCanNotMove\")) (\"IsOffBoard\" (where \"King\" Next))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))})))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "In standard chess, the captured piece is removed from the board and the capturing piece takes its place. In atomic chess, a capture causes an \\ "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n2x5 board. Five counters in each hole. Players take turns sowing in an anti-clockwise direction. When the final counter lands in a hole, the player picks up the contents of the next hole following this one, and continues sowing. If the player cannot pick up any counters from this hole, the players captures any counters from the hole after the empty hole, and the turn ends. Whenever any holes in the player's row contain four counters, they are captured by the player. Play continues until all of the counters have been captured. A new round begins. The players count their captured counters. If the difference between the two players' captured counters is greater than five, for each multiple of five in the difference a hole on the player with fewer counters' side is eliminated from play, and the excess counters that equal a multiple of five are placed aside for use in further rounds if necessary. When the difference is less than five, and when dealing with the remaining pieces after the multiples of five are dealt with, The following scenarios apply. When one player has one counter and the other has four, the player with one will give their stone to the one with four, but the player who has one counter will receive one counter from the hole from which sowing begins at the beginning of each player's turn. When one player has two counters and the other has three, the player with two gives these counters to the other player. With these five, the player creates a \\ \n\n### Response:\n",
    "completion": "(define \"DifferenceCapturedStone\" (abs (- (count Cell at:(handSite P1)) (count Cell at:(handSite P2))))) (define \"OneSeedOnBoard\" (= 1 (count Pieces All in:(union (sites Top) (sites Bottom))))) (define \"PlayableSites\" (sites (values Remembered \"Playable\"))) (define \"PlayFromNextLastHole\" (sites {(\"NextHoleFrom\" (last To afterConsequence:True) \"Track\" 1)})) (define \"NextHoleFrom\" (\"NextSiteOnTrack\" #3 from:#1 #2 #3)) (game \"Khutka Boia\" (players 2) (equipment { (mancalaBoard 2 5 store:None (track \"Track\" \"0,E,N,W\" loop:True)) (piece \"Seed\" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start { (set Count 5 to:(sites Track)) (set RememberValue \"Playable\" (union (sites Top) (sites Bottom)))}) phases:{ (phase \"Sowing\" (play (or { (or { (move Select (from (if (\"SameTurn\") \"PlayFromNextLastHole\" (sites Mover)) if:(and (is Occupied (from)) (is In (from) (\"PlayableSites\")))) (then (do (if (= 1 (value Player Next)) (fromTo (from (last From)) (to (handSite Mover)) count:1)) next:(sow (last From) apply:(if (is Occupied (\"NextHoleFrom\" (to) \"Track\" 1)) (moveAgain) (if (is Occupied (\"NextHoleFrom\" (to) \"Track\" 2)) (fromTo (from (\"NextHoleFrom\" (to) \"Track\" 2)) (to (handSite Mover)) count:(count at:(\"NextHoleFrom\" (to) \"Track\" 2))))) skipIf:(not (is In (to) (\"PlayableSites\")))))))} (then (and { (forEach Player (forEach Site (sites Player) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Player)) count:4)))) (forEach Site (sites P1) (if (and (is Occupied (site)) (= 1 (state at:(site)))) (and (fromTo (from (site)) (to (handSite Player)) count:(count at:(site))) (set State at:(site) 1)))) (forEach Site (sites P2) (if (and (is Occupied (site)) (= 2 (state at:(site)))) (and (fromTo (from (site)) (to (handSite Player)) count:(count at:(site))) (set State at:(site) 2))))})))} (then (if (\"OneSeedOnBoard\") (and { (forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forEach Site (sites Board) (if (!= 0 (state at:(site))) (set State at:(site) 0))) (set Value P1 0) (set Value P2 0) (forget Value \"Playable\" All)}))))) (end (if (\"NoPieceOnBoard\") { (if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (\"NoPieceOnBoard\") \"BetweenRounds\")) (phase \"BetweenRounds\" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 5 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (sites Mover) if:(is Empty (to))) count:5 (then (remember Value \"Playable\" (last To))))))) (nextPhase (all Passed) \"DecisionForNextRound\")) (phase \"DecisionForNextRound\" (play (if (> 5 (\"DifferenceCapturedStone\")) (do (if (= 1 (count Cell at:(handSite P1))) (and (set Value P1 1) (fromTo (from (handSite P1)) (to (handSite P2)) count:1)) (if (= 1 (count Cell at:(handSite P2))) (and (set Value P2 1) (fromTo (from (handSite P2)) (to (handSite P1)) count:1)) (if (= 2 (count Cell at:(handSite P2))) (set Var \"Bha\" 1) (if (= 2 (count Cell at:(handSite P1))) (set Var \"Bha\" 2))))) next:(if (= (var \"Bha\") P1) (move Select (from (intersection (union (sites Left) (sites Right)) (sites P1))) (then (and (set State at:(last To) 1) (set Var \"Bha\" 0)))) (if (= (var \"Bha\") P2) (move Select (from (intersection (union (sites Left) (sites Right)) (sites P2))) (then (and (set State at:(last To) 2) (set Var \"Bha\" 0)))) (move Pass)))) (move Pass))) (nextPhase \"Sowing\"))}))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "2x5 board. Five counters in each hole. Players take turns sowing in an anti-clockwise direction. When the final counter lands in a hole, the player picks up the contents of the next hole following this one, and continues sowing. If the player cannot pick up any counters from this hole, the players captures any counters from the hole after the empty hole, and the turn ends. Whenever any holes in the player's row contain four counters, they are captured by the player. Play continues until all of the counters have been captured. A new round begins. The players count their captured counters. If the difference between the two players' captured counters is greater than five, for each multiple of five in the difference a hole on the player with fewer counters' side is eliminated from play, and the excess counters that equal a multiple of five are placed aside for use in further rounds if necessary. When the difference is less than five, and when dealing with the remaining pieces after the multiples of five are dealt with, The following scenarios apply. When one player has one counter and the other has four, the player with one will give their stone to the one with four, but the player who has one counter will receive one counter from the hole from which sowing begins at the beginning of each player's turn. When one player has two counters and the other has three, the player with two gives these counters to the other player. With these five, the player creates a \\ "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(define \"IsFirstCheck\" (is Pending)) (define \"SetFirstCheck\" (set Pending)) (define \"RememberKingMovedOrChecked\" (set State at:#1 1)) (define \"KingMovedOrCheckedBefore\" (= 1 (state at:#1))) (define \"RookMovedBefore\" (= 1 (state at:#1))) (define \"RememberRookMoved\" (set State at:#1 1)) (define \"KingSites\" (sites {\"E8\" \"D1\"})) (define \"SitesNextToKing\" (sites {\"C1\" \"E1\" \"D8\" \"F8\"})) (game \"Main Chator\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (piece \"King_noCross\" (or (\"StepToNotFriend\" ~ (then (if (not (\"KingMovedOrCheckedBefore\" (last To))) (\"RememberKingMovedOrChecked\" (last To))))) (if (\"IsFirstCheck\") (or { (\"SlideCapture\" ~ (between (exact 2))) (\"LeapCapture\" \"KnightWalk\") (if (is In (from) (\"KingSites\")) (or (if (and { (is Empty (ahead (from) steps:2 W)) (\"IsPieceAt\" \"Rook\" Mover (ahead (from) W)) (not (\"RookMovedBefore\" (ahead (from) W)))}) (move (from) (to (ahead (from) steps:2 W)))) (if (and { (is Empty (ahead (from) steps:2 E)) (\"IsPieceAt\" \"Rook\" Mover (ahead (from) E)) (not (\"RookMovedBefore\" (ahead (from) E)))}) (move (from) (to (ahead (from) steps:2 E))))))})))) (\"ChessRook\" \"Rook\" ~ (then (if (and (not (\"RookMovedBefore\" (last To))) (not (is In (last To) (\"SitesNextToKing\")))) (\"RememberRookMoved\" (last To))))) (\"ChessBishop\" \"Bishop_noCross\") (\"ChessKnight\" \"Knight\") (piece \"Pawn\" (if (= 1 (state at:(from))) (\"StepToEmpty\" (directions {Rightward Leftward}) (then (set State at:(last To) 2))) (if (= 2 (state at:(from))) (\"StepToEmpty\" (directions {BR BL Rightward Leftward}) (then (promote (last To) (piece \"Queen\") Mover))) (or { \"StepForwardToEmpty\" (\"StepToEnemy\" (directions {FR FL}))} (then (if (is In (last To) (sites Mover \"Promotion\")) (if (is In (last To) (sites Corners)) (promote (last To) (piece \"Queen\") Mover) (set State at:(last To) 1)))))))) (\"ChessQueen\" \"Queen\") (regions \"Promotion\" P1 (sites Top)) (regions \"Promotion\" P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (sites Row 1)) (place \"Pawn2\" (sites Row 6)) (place \"Rook1\" {\"A1\" \"H1\"}) (place \"Knight1\" {\"B1\" \"G1\"}) (place \"Bishop_noCross1\" {\"C1\" \"F1\"}) (place \"Queen1\" coord:\"E1\") (place \"King_noCross1\" coord:\"D1\") (place \"Rook2\" {\"A8\" \"H8\"}) (place \"Knight2\" {\"B8\" \"G8\"}) (place \"Bishop_noCross2\" {\"C8\" \"F8\"}) (place \"Queen2\" coord:\"D8\") (place \"King_noCross2\" coord:\"E8\")}) (play (do (forEach Piece) ifAfterwards:(not (\"IsInCheck\" \"King_noCross\" Mover)) (then (if (\"IsInCheck\" \"King_noCross\" Next) (if (not (\"KingMovedOrCheckedBefore\" (where \"King_noCross\" Next))) (and (\"RememberKingMovedOrChecked\" (where \"King_noCross\" Next)) (\"SetFirstCheck\"))))))) (end (\"Checkmate\" \"King_noCross\"))))\n\n### Response:\n",
    "completion": "Played on an 8x8 board with pieces with specialized moves. The pieces are as follows, and placed on the outer rank in the following order, starting from the left corner and moving in, with the placement mirrored on the right side (the Mautri is placed to the right of the Rajah): Tor (2): can move any number of spaces orthogonally; Kudah (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Gajah (2): can move any number of spaces diagonally;  Rajah (1): can move one space orthogonally or diagonally; Mautri (1): can move any number of spaces orthogonally or diagonally; Bidah (8), placed in front of the other pieces: can move one space forward, or one space diagonally to capture. The Bidah are placed on the second file.  When first checked, the Rajah may move like a Kudah, or move two spaces in any direction. Players capture pieces by moving onto a space occupied by an opponent's piece. Castling may occur in two separate moves: the Tor moves next to the Rajah, and if the Rajah is checked, it may move to the other side of the Tor. Promotion of Bidahs occur when they reach the opposite edge of the board, but only immediately if they reach the Tor's square. Pawns reaching any other square must make two further moves before they can be promoted; the first must be a lateral orthogonal move, the second may be lateral orthogonal or diagonal. If the Rajah can be captured on the opponent's next turn, it is in check. The Rajah must not be in check at the end of the player's turn. If this is impossible, it is checkmate and the opponent wins. ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(define \"IsFirstCheck\" (is Pending)) (define \"SetFirstCheck\" (set Pending)) (define \"RememberKingMovedOrChecked\" (set State at:#1 1)) (define \"KingMovedOrCheckedBefore\" (= 1 (state at:#1))) (define \"RookMovedBefore\" (= 1 (state at:#1))) (define \"RememberRookMoved\" (set State at:#1 1)) (define \"KingSites\" (sites {\"E8\" \"D1\"})) (define \"SitesNextToKing\" (sites {\"C1\" \"E1\" \"D8\" \"F8\"})) (game \"Main Chator\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (piece \"King_noCross\" (or (\"StepToNotFriend\" ~ (then (if (not (\"KingMovedOrCheckedBefore\" (last To))) (\"RememberKingMovedOrChecked\" (last To))))) (if (\"IsFirstCheck\") (or { (\"SlideCapture\" ~ (between (exact 2))) (\"LeapCapture\" \"KnightWalk\") (if (is In (from) (\"KingSites\")) (or (if (and { (is Empty (ahead (from) steps:2 W)) (\"IsPieceAt\" \"Rook\" Mover (ahead (from) W)) (not (\"RookMovedBefore\" (ahead (from) W)))}) (move (from) (to (ahead (from) steps:2 W)))) (if (and { (is Empty (ahead (from) steps:2 E)) (\"IsPieceAt\" \"Rook\" Mover (ahead (from) E)) (not (\"RookMovedBefore\" (ahead (from) E)))}) (move (from) (to (ahead (from) steps:2 E))))))})))) (\"ChessRook\" \"Rook\" ~ (then (if (and (not (\"RookMovedBefore\" (last To))) (not (is In (last To) (\"SitesNextToKing\")))) (\"RememberRookMoved\" (last To))))) (\"ChessBishop\" \"Bishop_noCross\") (\"ChessKnight\" \"Knight\") (piece \"Pawn\" (if (= 1 (state at:(from))) (\"StepToEmpty\" (directions {Rightward Leftward}) (then (set State at:(last To) 2))) (if (= 2 (state at:(from))) (\"StepToEmpty\" (directions {BR BL Rightward Leftward}) (then (promote (last To) (piece \"Queen\") Mover))) (or { \"StepForwardToEmpty\" (\"StepToEnemy\" (directions {FR FL}))} (then (if (is In (last To) (sites Mover \"Promotion\")) (if (is In (last To) (sites Corners)) (promote (last To) (piece \"Queen\") Mover) (set State at:(last To) 1)))))))) (\"ChessQueen\" \"Queen\") (regions \"Promotion\" P1 (sites Top)) (regions \"Promotion\" P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (sites Row 1)) (place \"Pawn2\" (sites Row 6)) (place \"Rook1\" {\"A1\" \"H1\"}) (place \"Knight1\" {\"B1\" \"G1\"}) (place \"Bishop_noCross1\" {\"C1\" \"F1\"}) (place \"Queen1\" coord:\"E1\") (place \"King_noCross1\" coord:\"D1\") (place \"Rook2\" {\"A8\" \"H8\"}) (place \"Knight2\" {\"B8\" \"G8\"}) (place \"Bishop_noCross2\" {\"C8\" \"F8\"}) (place \"Queen2\" coord:\"D8\") (place \"King_noCross2\" coord:\"E8\")}) (play (do (forEach Piece) ifAfterwards:(not (\"IsInCheck\" \"King_noCross\" Mover)) (then (if (\"IsInCheck\" \"King_noCross\" Next) (if (not (\"KingMovedOrCheckedBefore\" (where \"King_noCross\" Next))) (and (\"RememberKingMovedOrChecked\" (where \"King_noCross\" Next)) (\"SetFirstCheck\"))))))) (end (\"Checkmate\" \"King_noCross\"))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(define \"HexHex\" (board (tri Hexagon 6) use:Vertex)) (define \"BoardUsed\" \"HexHex\") (define \"Connection\" Orthogonal) (define \"CaptureSurroundedPiece\" (enclose (from (last To)) Orthogonal (between if:(\"IsEnemyAt\" (between)) (apply (and (addScore Mover 1) (remove (between))))))) (game \"HexGo\" (players 2) (equipment { \"BoardUsed\" (piece \"Ball\" P1) (piece \"Ball\" P2)}) (rules (meta (no Repeat)) (play (or (do (move Add (to (sites Empty)) (then \"CaptureSurroundedPiece\")) ifAfterwards:(\"HasFreedom\" Orthogonal)) (move Pass))) (end (if (all Passed) (byScore { (score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))})))))\n\n### Response:\n",
    "completion": "The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players total the number of intersections their pieces occupy or surround. The player with the highest total wins. For more info on this version please google Hexagonal Go. Hex Grid - Standard Order 6 board",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(define \"HexHex\" (board (tri Hexagon 6) use:Vertex)) (define \"BoardUsed\" \"HexHex\") (define \"Connection\" Orthogonal) (define \"CaptureSurroundedPiece\" (enclose (from (last To)) Orthogonal (between if:(\"IsEnemyAt\" (between)) (apply (and (addScore Mover 1) (remove (between))))))) (game \"HexGo\" (players 2) (equipment { \"BoardUsed\" (piece \"Ball\" P1) (piece \"Ball\" P2)}) (rules (meta (no Repeat)) (play (or (do (move Add (to (sites Empty)) (then \"CaptureSurroundedPiece\")) ifAfterwards:(\"HasFreedom\" Orthogonal)) (move Pass))) (end (if (all Passed) (byScore { (score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))})))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nFive squares which are each divided with lines connecting the midpoints of their sides and diagonals. The five squares are arranged in a cross-shaped board. One player plays as two foxes the other as twenty hens. The hens begin on the twenty spaces on one half of the board, the foxes on the bottom two corners of the square on the opposite arm of the cross. The foxes may move in any direction, and hop over a hen to an empty space immediately adjacent on the opposite side of the hen along the lines of the board to capture. The hens may not move backward. The foxes win by capturing all the hens, the hens win by occupying all of the spaces in the square of the arm of the cross opposite from where they began. \n\n### Response:\n",
    "completion": "(game \"El Zorro\" (\"TwoPlayersNorthSouth\") (equipment { (\"CrossBoard\" 3 7 use:Vertex diagonals:Alternating) (piece \"Fox\" P1 (or (\"HopCapture\") \"StepToEmpty\")) (piece \"Hen\" P2 (\"StepToEmpty\" (directions {Rightward Leftward Forwards})))}) (rules (start { (place \"Hen2\" (union (sites Top) (expand (sites Row 4)))) (place \"Fox1\" (intersection (union (sites Column 4) (sites Column 2)) (sites Bottom)))}) (play (forEach Piece)) (end { (if (all Sites (expand (sites Bottom) steps:2) if:(= (who at:(site)) P2)) (result P2 Win)) (if (no Pieces P2) (result P1 Win))})))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Five squares which are each divided with lines connecting the midpoints of their sides and diagonals. The five squares are arranged in a cross-shaped board. One player plays as two foxes the other as twenty hens. The hens begin on the twenty spaces on one half of the board, the foxes on the bottom two corners of the square on the opposite arm of the cross. The foxes may move in any direction, and hop over a hen to an empty space immediately adjacent on the opposite side of the hen along the lines of the board to capture. The hens may not move backward. The foxes win by capturing all the hens, the hens win by occupying all of the spaces in the square of the arm of the cross opposite from where they began. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(define \"SowedHoles\" (if (is Mover P1) (values Remembered \"SowedHolesP1\") (values Remembered \"SowedHolesP2\"))) (define \"RemmemberSowedHoles\" (if (is Mover P1) (remember Value \"SowedHolesP1\" #1 unique:True) (remember Value \"SowedHolesP2\" #1 unique:True))) (define \"NextHole\" (\"NextSiteOnTrack\" #2 from:#1 \"Track\")) (game \"Adjiboto\" (players 2) (equipment { (mancalaBoard 2 5 store:None (track \"Track\" \"0,E,N,W\" loop:True)) (piece \"Seed\" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 10 to:(sites Track))) phases:{ (phase \"Opening\" (play (move Select (from (difference (sites Mover) (sites (\"SowedHoles\"))) if:(< 1 (count at:(to)))) (then (and (sow origin:True) (\"RemmemberSowedHoles\" (last From)))))) (nextPhase Mover (< 8 (count Turns)))) (phase \"Main\" (play (move Select (from (sites Mover) if:(< 1 (count at:(to)))) (then (sow if:(or { (= 1 (count at:(\"NextHole\" (to) 1))) (= 3 (count at:(\"NextHole\" (to) 1))) (= 5 (count at:(\"NextHole\" (to) 1)))}) apply:(fromTo (from (\"NextHole\" (to) 1)) (to (handSite Mover)) count:(count at:(\"NextHole\" (to) 1))) origin:True forward:True)))) (end (if (no Moves Next) { (if (< (count Cell at:(handSite Next)) 50) (result Mover Win)) (if (>= (count Cell at:(handSite Next)) 50) (result Mover Draw))})))}))\n\n### Response:\n",
    "completion": "2x5 board. Ten counters in each hole. Sowing occurs in an anti-clockwise direction, sowing first into the hole from which the counters originally came. Opening phase: In the first ten turns, each player must sow from each of their five holes. Main phase: Captures are made when the last counter of a sowing falls into a hole preceding a hole containing one, three, or five counters. These counters are taken. Any subsequent holes also containing one, three, or five counters are captured, until a hole is reached that does not have one of these numbers of counters. The exception to this is in the first move when no captures are made. Sowing cannot begin from a hole with a single counter. A player wins when his opponent can no longer sow. However, if a player can no longer move, they can redistribute their captured beans into their holes, and if all five can be filled with ten, the game is a draw. ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(define \"SowedHoles\" (if (is Mover P1) (values Remembered \"SowedHolesP1\") (values Remembered \"SowedHolesP2\"))) (define \"RemmemberSowedHoles\" (if (is Mover P1) (remember Value \"SowedHolesP1\" #1 unique:True) (remember Value \"SowedHolesP2\" #1 unique:True))) (define \"NextHole\" (\"NextSiteOnTrack\" #2 from:#1 \"Track\")) (game \"Adjiboto\" (players 2) (equipment { (mancalaBoard 2 5 store:None (track \"Track\" \"0,E,N,W\" loop:True)) (piece \"Seed\" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 10 to:(sites Track))) phases:{ (phase \"Opening\" (play (move Select (from (difference (sites Mover) (sites (\"SowedHoles\"))) if:(< 1 (count at:(to)))) (then (and (sow origin:True) (\"RemmemberSowedHoles\" (last From)))))) (nextPhase Mover (< 8 (count Turns)))) (phase \"Main\" (play (move Select (from (sites Mover) if:(< 1 (count at:(to)))) (then (sow if:(or { (= 1 (count at:(\"NextHole\" (to) 1))) (= 3 (count at:(\"NextHole\" (to) 1))) (= 5 (count at:(\"NextHole\" (to) 1)))}) apply:(fromTo (from (\"NextHole\" (to) 1)) (to (handSite Mover)) count:(count at:(\"NextHole\" (to) 1))) origin:True forward:True)))) (end (if (no Moves Next) { (if (< (count Cell at:(handSite Next)) 50) (result Mover Win)) (if (>= (count Cell at:(handSite Next)) 50) (result Mover Draw))})))}))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nDefines a forward slide move to empty sites at distance 2.\n\n### Response:\n",
    "completion": "(define \"DoubleStepForwardToEmpty\" (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) #1))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Defines a forward slide move to empty sites at distance 2."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nThe board is 8x8. -> The board is 10x10.\n\n### Input:\n(game \"T'uk T'uk\" (players 2) (equipment { (board (square 8)) (piece \"Marker\" Each (move Slide Orthogonal))}) (rules (start { (place \"Marker1\" (sites Bottom)) (place \"Marker2\" (sites Top))}) (play (forEach Piece)) (end (\"BlockWin\"))))\n\n### Response:\n",
    "completion": "(game \"T'uk T'uk\" (players 2) (equipment { (board (square 10)) (piece \"Marker\" Each (move Slide Orthogonal))}) (rules (start { (place \"Marker1\" (sites Bottom)) (place \"Marker2\" (sites Top))}) (play (forEach Piece)) (end (\"BlockWin\"))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nThe board is 8x8. -> The board is 10x10.",
    "_var_input": "(game \"T'uk T'uk\" (players 2) (equipment { (board (square 8)) (piece \"Marker\" Each (move Slide Orthogonal))}) (rules (start { (place \"Marker1\" (sites Bottom)) (place \"Marker2\" (sites Top))}) (play (forEach Piece)) (end (\"BlockWin\"))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayed on an 8x8 board with 12 pieces per side. Pieces move one space diagonally. Capturing occurs when an opponent's piece is adjacent to a player's piece and there is an open space on the other side of the opponent and the player's piece jumps the opponent's. Capturing can happen either forwards or backwards. Capturing must happen if it is possible. Multiple jumps can be made in a turn, and the maximum number of jumps must be made. Pieces become kings when they reach the opposite side of the board from which they started at the end of its turn. Kings can move multiple spaces in one direction. \n\n### Response:\n",
    "completion": "(define \"IsUnpromoted\" (\"IsPieceAt\" \"Counter\" Mover (last To))) (game \"Brazilian Draughts\" (players 2) (\"DraughtsEquipment\" (square 8)) (rules (\"BlackCellsSetup\" 3) (play (if \"SameTurn\" (if \"IsUnpromoted\" (max Moves (\"HopInternationalDraughtsStyle\" (from (last To)) (then (\"ReplayIfCanMove\" (\"HopInternationalDraughtsStyle\" (from (last To))) (\"PromoteIfReach\" (sites Next) \"DoubleCounter\"))))) (max Moves (\"HopDiagonalSequenceCaptureAgain\" before:(count Rows) after:(count Rows) at:EndOfTurn))) (priority { (max Moves (or (forEach Piece \"Counter\" (\"HopInternationalDraughtsStyle\" (from) (then (\"ReplayIfCanMove\" (\"HopInternationalDraughtsStyle\" (from (last To))) (\"PromoteIfReach\" (sites Next) \"DoubleCounter\"))))) (forEach Piece \"DoubleCounter\" (\"HopDiagonalSequenceCapture\" before:(count Rows) after:(count Rows) at:EndOfTurn)))) (or (forEach Piece \"Counter\" (\"StepToEmpty\" (directions {FR FL})) (then (\"PromoteIfReach\" (sites Next) \"DoubleCounter\"))) (forEach Piece \"DoubleCounter\" (move Slide Diagonal)))}))) (end (\"BlockWin\"))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Played on an 8x8 board with 12 pieces per side. Pieces move one space diagonally. Capturing occurs when an opponent's piece is adjacent to a player's piece and there is an open space on the other side of the opponent and the player's piece jumps the opponent's. Capturing can happen either forwards or backwards. Capturing must happen if it is possible. Multiple jumps can be made in a turn, and the maximum number of jumps must be made. Pieces become kings when they reach the opposite side of the board from which they started at the end of its turn. Kings can move multiple spaces in one direction. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Both players begin in the same quadrant of the board. One player's pieces are arranged as follows: Eight on the first point of the quadrant to their left, four on the fifth, and three on the sixth. The other player places five on the second, third, and fourth space of the same quadrant. The track proceeds in a clockwise direction around the board. When a player's piece lands on a space occupied by a single piece of the opponent, it is sent back to the beginning of the quadrant to the right of the starting quadrant. Pieces bear off from the quadrant diagonal from the starting quadrant. The first player to bear off all their pieces wins. \n\n### Response:\n",
    "completion": "(define \"NextSiteFrom\" (\"NextSiteOnTrack\" #2 from:#1)) (game \"Seys Dos y As\" (players 2) (equipment { (\"TableBoard\" { (track \"Track1\" {24 11..0 12..17} P1 directed:True) (track \"Track2\" {25 11..0 12..17} P2 directed:True)}) (dice d:6 num:3) (piece \"Disc\" Each (forEach Die if:(\"DieNotUsed\") (if (\"IsOffBoard\" (\"NextSiteFrom\" (from) (pips))) (move Remove (from)) (move (from (from)) (to (\"NextSiteFrom\" (from) (pips)) if:(\"NoEnemyOrOnlyOne\" (to)) (\"HittingCapture\" (handSite Next))))) (then (\"ReplayNotAllDiceUsed\")))) (hand Each)}) (rules (start { (place Stack \"Disc1\" 11 count:8) (place Stack \"Disc1\" 6 count:3) (place Stack \"Disc1\" 7 count:4) (place Stack \"Disc2\" (sites {10..8}) count:5)}) (play (\"RollEachNewTurnMove\" (or (forEach Piece top:True) (forEach Piece container:(mover) top:True)))) (end (\"EscapeWin\"))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Both players begin in the same quadrant of the board. One player's pieces are arranged as follows: Eight on the first point of the quadrant to their left, four on the fifth, and three on the sixth. The other player places five on the second, third, and fourth space of the same quadrant. The track proceeds in a clockwise direction around the board. When a player's piece lands on a space occupied by a single piece of the opponent, it is sent back to the beginning of the quadrant to the right of the starting quadrant. Pieces bear off from the quadrant diagonal from the starting quadrant. The first player to bear off all their pieces wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayed on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays with one larger piece, the Oke-mow, placed on the central point, and the other player with thirteen pieces situated on every point of one arm of the cross and along the line immediately perpendicular to that arm. Pieces move along the lines to an adjacent empty spot. The Oke-mow may jump over an adjacent piece to capture it. Multiple captures are allowed. The Oke-mow wins if it can capture all the opponent's pieces, the other player wins by blocking the Oke-mow from moving.\n         \n\n### Response:\n",
    "completion": "(game \"Musinaykahwhanmetowaywin\" (players 2) (equipment { (\"CrossBoard\" 3 7 use:Vertex diagonals:Alternating) (piece \"Marker\" P1 (or (\"HopSequenceCapture\") (\"StepToEmpty\"))) (piece \"Disc\" P2 (\"StepToEmpty\"))}) (rules (start { (place \"Disc2\" (union (expand (sites Bottom)) (sites Row 2))) (place \"Marker1\" (centrePoint))}) (play (if \"SameTurn\" (or (\"HopSequenceCaptureAgain\") (move Pass)) (forEach Piece))) (end (\"NoMovesP1NoPiecesP2\"))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Played on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays with one larger piece, the Oke-mow, placed on the central point, and the other player with thirteen pieces situated on every point of one arm of the cross and along the line immediately perpendicular to that arm. Pieces move along the lines to an adjacent empty spot. The Oke-mow may jump over an adjacent piece to capture it. Multiple captures are allowed. The Oke-mow wins if it can capture all the opponent's pieces, the other player wins by blocking the Oke-mow from moving.\n         "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nReversi is played on an 8x8 board. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. Play begins with the players taking turns placing pieces into the central four squares until they are full. Then players may place their pieces next to an opponent's piece, a long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player cannot make a legal move. The player with the most pieces on the board wins. The pieces are placed on the board. The board is a square board of size 8x8.\n\n### Response:\n",
    "completion": "(define \"ReverseBoundedPieces\" (custodial (from (site)) (between if:(is Enemy (state at:(between))) (apply (allCombinations (add (piece \"Disc0\" state:(mover)) (to (site))) (flip (between))))) (to if:(is Friend (state at:(to)))))) (game \"Reversi\" (players 2) (equipment { (board (square 8)) (piece \"Disc\" Neutral (flips 1 2))}) (rules (start { (place \"Disc0\" (difference (sites Centre) (sites Phase 1)) state:1) (place \"Disc0\" (difference (sites Centre) (sites Phase 0)) state:2)}) phases:{ (phase \"Playing\" (play (forEach Site (sites Empty) (append \"ReverseBoundedPieces\" (then (and (set Score P1 (count Sites in:(sites State 1))) (set Score P2 (count Sites in:(sites State 2)))))))))} (end (if (all Passed) (byScore)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Reversi is played on an 8x8 board. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. Play begins with the players taking turns placing pieces into the central four squares until they are full. Then players may place their pieces next to an opponent's piece, a long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player cannot make a legal move. The player with the most pieces on the board wins. The pieces are placed on the board. The board is a square board of size 8x8."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n5x5 board, the central square marked with an X. Twelve pieces per player. Pieces begin the game on the first two rows in front of the player, and in the two squares to the player's right in the central row. Players alternate turns moving a piece orthogonally to an adjacent empty space. Players may capture an opponent's piece by hopping over it. The player who captures all of the opponent's pieces wins. \n\n### Response:\n",
    "completion": "(game \"Natt Klab ash-Shawk\" (players 2) (equipment { (board (square 5)) (piece \"Marker\" Each (or (\"StepOrthogonalToEmpty\") (\"HopOrthogonalCapture\")))}) (rules (start { (place \"Marker1\" (union {(expand (sites Bottom)) (sites {\"D3\" \"E3\"})})) (place \"Marker2\" (union {(sites {\"A3\" \"B3\"}) (expand (sites Top))}))}) (play (forEach Piece)) (end (\"CaptureAll\" Next))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "5x5 board, the central square marked with an X. Twelve pieces per player. Pieces begin the game on the first two rows in front of the player, and in the two squares to the player's right in the central row. Players alternate turns moving a piece orthogonally to an adjacent empty space. Players may capture an opponent's piece by hopping over it. The player who captures all of the opponent's pieces wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayed on a board with two rows of five spaces forming an \\ \n\n### Response:\n",
    "completion": "(define \"ReplaceStick\" (move (from (handSite Mover)) (to (sites Empty)) (then (moveAgain)))) (define \"LessThanFourSticksOnBoard\" (< (count Sites in:(sites Occupied by:Mover container:\"Board\")) 4)) (define \"HaveRemainingSticks\" (\"HandOccupied\" Mover)) (game \"Queah Game\" (players 2) (equipment { (board (rotate 45 (merge (shift 1 -1 (rectangle 5 1)) (merge (shift -1 1 (rectangle 1 5)) (square 3))))) (piece \"Stick\" Each (or (\"StepOrthogonalToEmpty\") (\"HopOrthogonalCapture\"))) (hand Each)}) (rules (start { (place \"Stick1\" {\"A1\" \"B2\" \"A3\" \"B4\"}) (place \"Stick2\" {\"E5\" \"D4\" \"E3\" \"D2\"}) (place \"Stick\" \"Hand\" count:6)}) (play (if (and (\"HaveRemainingSticks\") (\"LessThanFourSticksOnBoard\")) (\"ReplaceStick\") (forEach Piece))) (end (\"CaptureAll\" Next))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Played on a board with two rows of five spaces forming an \\ "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(game \"Ring\" (players 2) (equipment { (board (concentric {1 8}) use:Vertex) (hand Each) (piece \"Marker\" Each \"StepToEmpty\")}) (rules (start (place \"Marker\" \"Hand\" count:3)) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre))))) (nextPhase Mover \"PlacementAdjacent\")) (phase \"PlacementAdjacent\" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre)) if:(is In (to) (sites Around (sites Occupied by:Mover)))))) (nextPhase (\"HandEmpty\" P2) \"Movement\")) (\"PhaseMovePiece\" \"Movement\")} (end (if (is Line 3 through:(centrePoint) what:(mover)) (result Mover Win)))))\n\n### Response:\n",
    "completion": "A circle with eight radii. Three pieces per player. Each player has three pieces, which must start on the outer ring adjacent to each other. Players alternate turns moving a piece to an empty point along the lines of the board. The player who makes a line of three through the center of the circle wins. ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(game \"Ring\" (players 2) (equipment { (board (concentric {1 8}) use:Vertex) (hand Each) (piece \"Marker\" Each \"StepToEmpty\")}) (rules (start (place \"Marker\" \"Hand\" count:3)) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre))))) (nextPhase Mover \"PlacementAdjacent\")) (phase \"PlacementAdjacent\" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre)) if:(is In (to) (sites Around (sites Occupied by:Mover)))))) (nextPhase (\"HandEmpty\" P2) \"Movement\")) (\"PhaseMovePiece\" \"Movement\")} (end (if (is Line 3 through:(centrePoint) what:(mover)) (result Mover Win)))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(game \"Katsela\" (players 2) (equipment { (\"AlquerqueBoard\" 3 3) (hand Each) (piece \"Marker\" Each (\"StepToEmpty\"))}) (rules (start (place \"Marker\" \"Hand\" count:3)) phases:{ (phase \"Opening\" (play (move (from (handSite Mover)) (to (centrePoint)))) (nextPhase \"Placing\")) (phase \"Placing\" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (\"HandEmpty\" Mover) \"Moving\")) (phase \"Moving\" (play (forEach Piece)))} (end (\"Line3Win\"))))\n\n### Response:\n",
    "completion": "Three intersecting lines, with diagonals drawn in the square. Two players. Three pieces per player, one playing as red and the other as white. The red player plays first and places their piece in the central spot. Players alternate turns placing one of their pieces on an empty space on the board. When all of the pieces are placed, players alternate turns moving one of their pieces to an empty adjacent spot on the board along the lines. The first player to place three of their pieces in a row wins. ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(game \"Katsela\" (players 2) (equipment { (\"AlquerqueBoard\" 3 3) (hand Each) (piece \"Marker\" Each (\"StepToEmpty\"))}) (rules (start (place \"Marker\" \"Hand\" count:3)) phases:{ (phase \"Opening\" (play (move (from (handSite Mover)) (to (centrePoint)))) (nextPhase \"Placing\")) (phase \"Placing\" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (\"HandEmpty\" Mover) \"Moving\")) (phase \"Moving\" (play (forEach Piece)))} (end (\"Line3Win\"))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nSquare 8 x 8, one row -> Square 8 x 8, two rows\n\n### Input:\n(define \"ThrowStonetoEnemy\" (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if: (\"IsEnemyAt\" (to))) (then (and (remove (last To)) (remove (last To)))))) (define \"ThrowStonetoEmpty\" (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if: (and (not (\"IsEnemyAt\" (to))) (not (is Mover (who at:(to)))))))) (define \"SacrificeCaptureCatapult\" (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (\"IsEnemyAt\" (to)) (= (size Stack at:(to)) 3)) (apply (remove (to)))) stack:True (then (and { (fromTo (from (last To)) (to (last From))) (remove (last To)) (moveAgain)})))) (define \"SacrificeCaptureWall\" (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (\"IsEnemyAt\" (to)) (\"IsSingletonStack\" (to))) (apply (remove (to)))) stack:True (then (and (fromTo (from (last To)) (to (last From))) (remove (last To)))))) (define \"MoveTower\" (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (between if:(or (is Empty (between)) (and (is Mover (who at:(between))) (< (size Stack at:(between)) 2))) (apply (fromTo (from) (to (between))))) (to if:(or (is Empty (to)) (and (is Mover (who at:(to))) (< (size Stack at:(to)) 2)))) stack:True)) (game \"Murus Gallicus\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (piece \"Counter_isometric\" Each) (regions \"RomanGoal1\" P1 (sites Top)) (regions \"GaulGoal2\" P2 (sites Bottom))}) (rules (start { (place Stack \"Counter_isometric1\" (sites {0..7}) count:2) (place Stack \"Counter_isometric2\" (sites {56..63}) count:2)}) (play (if (\"SameTurn\") (or (move (from (last From)) (to (last To)) stack:True (then (and (remove (last To)) (remove (last To))))) (move Pass)) (forEach Piece \"Counter_isometric\" (or { \"MoveTower\" \"SacrificeCaptureWall\" \"SacrificeCaptureCatapult\" \"ThrowStonetoEmpty\" \"ThrowStonetoEnemy\"}) top:True))) (end { (\"BlockWin\") (if (and { (is In (last To) (sites Mover)) (not (\"IsEnemyAt\" (last To))) (is Mover (who at:(last To)))}) (result Mover Win))})))\n\n### Response:\n",
    "completion": "(define \"ThrowStonetoEnemy\" (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if: (\"IsEnemyAt\" (to))) (then (and (remove (last To)) (remove (last To)))))) (define \"ThrowStonetoEmpty\" (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if: (and (not (\"IsEnemyAt\" (to))) (not (is Mover (who at:(to)))))))) (define \"SacrificeCaptureCatapult\" (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (\"IsEnemyAt\" (to)) (= (size Stack at:(to)) 3)) (apply (remove (to)))) stack:True (then (and { (fromTo (from (last To)) (to (last From))) (remove (last To)) (moveAgain)})))) (define \"SacrificeCaptureWall\" (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (\"IsEnemyAt\" (to)) (\"IsSingletonStack\" (to))) (apply (remove (to)))) stack:True (then (and (fromTo (from (last To)) (to (last From))) (remove (last To)))))) (define \"MoveTower\" (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (between if:(or (is Empty (between)) (and (is Mover (who at:(between))) (< (size Stack at:(between)) 2))) (apply (fromTo (from) (to (between))))) (to if:(or (is Empty (to)) (and (is Mover (who at:(to))) (< (size Stack at:(to)) 2)))) stack:True)) (game \"Murus Gallicus\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (piece \"Counter_isometric\" Each) (regions \"RomanGoal1\" P1 (sites Top)) (regions \"GaulGoal2\" P2 (sites Bottom))}) (rules (start { (place Stack \"Counter_isometric1\" (sites {0..15}) count:2) (place Stack \"Counter_isometric2\" (sites {48..63}) count:2)}) (play (if (\"SameTurn\") (or (move (from (last From)) (to (last To)) stack:True (then (and (remove (last To)) (remove (last To))))) (move Pass)) (forEach Piece \"Counter_isometric\" (or { \"MoveTower\" \"SacrificeCaptureWall\" \"SacrificeCaptureCatapult\" \"ThrowStonetoEmpty\" \"ThrowStonetoEnemy\"}) top:True))) (end { (\"BlockWin\") (if (and { (is In (last To) (sites Mover)) (not (\"IsEnemyAt\" (last To))) (is Mover (who at:(last To)))}) (result Mover Win))})))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nSquare 8 x 8, one row -> Square 8 x 8, two rows",
    "_var_input": "(define \"ThrowStonetoEnemy\" (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if: (\"IsEnemyAt\" (to))) (then (and (remove (last To)) (remove (last To)))))) (define \"ThrowStonetoEmpty\" (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if: (and (not (\"IsEnemyAt\" (to))) (not (is Mover (who at:(to)))))))) (define \"SacrificeCaptureCatapult\" (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (\"IsEnemyAt\" (to)) (= (size Stack at:(to)) 3)) (apply (remove (to)))) stack:True (then (and { (fromTo (from (last To)) (to (last From))) (remove (last To)) (moveAgain)})))) (define \"SacrificeCaptureWall\" (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (\"IsEnemyAt\" (to)) (\"IsSingletonStack\" (to))) (apply (remove (to)))) stack:True (then (and (fromTo (from (last To)) (to (last From))) (remove (last To)))))) (define \"MoveTower\" (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (between if:(or (is Empty (between)) (and (is Mover (who at:(between))) (< (size Stack at:(between)) 2))) (apply (fromTo (from) (to (between))))) (to if:(or (is Empty (to)) (and (is Mover (who at:(to))) (< (size Stack at:(to)) 2)))) stack:True)) (game \"Murus Gallicus\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (piece \"Counter_isometric\" Each) (regions \"RomanGoal1\" P1 (sites Top)) (regions \"GaulGoal2\" P2 (sites Bottom))}) (rules (start { (place Stack \"Counter_isometric1\" (sites {0..7}) count:2) (place Stack \"Counter_isometric2\" (sites {56..63}) count:2)}) (play (if (\"SameTurn\") (or (move (from (last From)) (to (last To)) stack:True (then (and (remove (last To)) (remove (last To))))) (move Pass)) (forEach Piece \"Counter_isometric\" (or { \"MoveTower\" \"SacrificeCaptureWall\" \"SacrificeCaptureCatapult\" \"ThrowStonetoEmpty\" \"ThrowStonetoEnemy\"}) top:True))) (end { (\"BlockWin\") (if (and { (is In (last To) (sites Mover)) (not (\"IsEnemyAt\" (last To))) (is Mover (who at:(last To)))}) (result Mover Win))})))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nDefines a move from a region to any empty sites or sites occupied by a larger pieces on the board. This ludemeplex involves stacks and the size of the piece are related to the indexes of the pieces (in the hypothesis that each player has the same number of pieces). Some graphic metadata will be needed to scale the pieces according to this.\n\n### Response:\n",
    "completion": "(define \"MoveToEmptyOrOccupiedByLargerPiece\" (move (from #1) (to (sites Board) if:(and (!= (from) (to)) (or (is Empty (to)) (< (- (what at:(from) level:(topLevel at:(from))) (who at:(from) level:(topLevel at:(from)))) (- (what at:(to) level:(topLevel at:(to))) (who at:(to) level:(topLevel at:(to))))))))))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Defines a move from a region to any empty sites or sites occupied by a larger pieces on the board. This ludemeplex involves stacks and the size of the piece are related to the indexes of the pieces (in the hypothesis that each player has the same number of pieces). Some graphic metadata will be needed to scale the pieces according to this."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayers alternate making a move. White plays with the white stones and makes the first move, Black plays with the black stones. On his turn, a player may choose either a) to place a stone on the board without contact to other stones of his color in order to start a new group, or b) to grow all possible groups by one stone. When you grow your groups in this implementation, you place grey stones adjacent to your groups until each of your groups is adjacent to exactly one grey stone. At no point may a group of yours be adjacent to more than one grey stone. When your turn ends, all grey stones are replaced with stones of your color.\n    \n    For balancing, there is an extra rule: Black is allowed to grow all his groups and place a single stone as long as neither player has not yet grown any groups.\n    \nThe game ends when the board is filled in. The score is the number of stones each player has on the board minus 'P' times the number of groups he has, where 'P' is en even number of 4 or higher (the Ludii implementation also allows 0 and 2 as values of 'P'). With an even penalty and an odd boardsize, draws are not possible. A size 19 board is currently selected A group penalty of 10 points is currently selected\n\n### Response:\n",
    "completion": "(define \"UpdateScore\" (set Score Mover (- (count Sites in:(sites Occupied by:Mover)) (* 10 (count Groups Orthogonal if:(is Mover (who at:(to)))))))) (define \"Grow\" (\"PlaceGrey\" (then (if (can Move (\"PlaceGrey\" ~)) (moveAgain) (do (\"ReplaceAllGrey\") next:(\"UpdateScore\")))))) (define \"ReplaceAllGrey\" (add (to (sites Occupied by:Neutral) (apply (remove (to)))) (then (if (!= 1 (var \"HasGrown\")) (and (set Var \"HasGrown\" 1) (if (= (id P2) (mover)) (and (set Var \"MoveThatMustBePlant\" (count Moves)) (moveAgain)))))))) (define \"PlaceGrey\" (do (move Add (piece \"Marker0\") (to (sites Empty) if:(< 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(> 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))) #1)) (define \"Plant\" (move Add (to (sites Empty) if:(= 0 (count Sites in:(sites Around (to) Own Orthogonal)))) (then (\"UpdateScore\")))) (game \"Symple\" (players 2) (equipment { (board (square 19) use:Vertex) (piece \"Marker\" Each) (piece \"Marker\" Neutral)}) (rules (play (if (= (count Moves) (var \"MoveThatMustBePlant\")) (\"Plant\") (if (= 0 (count MovesThisTurn)) (or (\"Plant\") (\"Grow\")) (\"Grow\")))) (end (if (is Full) (byScore)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Players alternate making a move. White plays with the white stones and makes the first move, Black plays with the black stones. On his turn, a player may choose either a) to place a stone on the board without contact to other stones of his color in order to start a new group, or b) to grow all possible groups by one stone. When you grow your groups in this implementation, you place grey stones adjacent to your groups until each of your groups is adjacent to exactly one grey stone. At no point may a group of yours be adjacent to more than one grey stone. When your turn ends, all grey stones are replaced with stones of your color.\n    \n    For balancing, there is an extra rule: Black is allowed to grow all his groups and place a single stone as long as neither player has not yet grown any groups.\n    \nThe game ends when the board is filled in. The score is the number of stones each player has on the board minus 'P' times the number of groups he has, where 'P' is en even number of 4 or higher (the Ludii implementation also allows 0 and 2 as values of 'P'). With an even penalty and an odd boardsize, draws are not possible. A size 19 board is currently selected A group penalty of 10 points is currently selected"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nObjectives\n            One player has a gold fleet consisting of one large flagship and twelve escorts, with the objective of evading capture while breaking through his or her opponent's blockade to transport the flagship to the perimeter of the board. The other player has a silver fleet of twenty ships, and forms a blockade to trap the gold flagship and destroy the gold fleet's escorts with the objective of capturing the flagship.\n            \n            Setup\n            Gold player places the flagship on the center square of the game board, and positions the rest of the ships anywhere within the boldly ruled central area of the board.\n            \n            Silver player then positions the silver ships on twenty squares in the lightly ruled peripheral area of the board.\n            \n            Play\n            Gold player chooses who goes first. Players move alternately by making two moves or one capture anywhere on the board. When the flagship is moved, only one move or capture is made (thus only the flagship).\n            \n            Moves\n            A player may move two of the smaller playing pieces any number of vacant squares either horizontally or vertically on the board (as a rook in Chess, except that no captures can be made with this move), although if the flagship is moved, the gold player may not move another playing piece.\n            \n            Captures\n            A player may move any playing piece (including the flagship) one square diagonally to capture one of his opponent's playing pieces. (This move is similar to the capture-move of the pawn in Chess, except that captures can be made on any of the four diagonals.)\n            \n            This game uses displacement capture (like Chess), rather than custodial capture (like Hnefatafl), thus when a capture is made, the captured piece is removed from the board and the vacated square is occupied by the captor.\n            \n        Play continues until one player achieves his or her objective. If the flagship of the gold fleet reaches one of the outermost squares on the board, gold player wins. If the flagship is captured before it reaches the outer edge of the board, silver player wins. \n\n### Response:\n",
    "completion": "(game \"Breakthru\" (players 2) (equipment { (board (square 11)) (piece \"Disc\" Each (or (if (\"NewTurn\") (\"StepToEnemy\" Diagonal)) (move Slide Orthogonal (then (if (\"NewTurn\") (moveAgain)))))) (piece \"Commander\" P1 (if (\"NewTurn\") (or (\"StepToEnemy\" Diagonal) (move Slide Orthogonal)))) (hand Each) (regions \"CentreSites\" (expand (sites Centre) steps:2))}) (rules (start { (place \"Commander1\" (sites Centre)) (place \"Disc1\" (handSite P1) count:12) (place \"Disc2\" (handSite P2) count:20)}) phases: { (phase \"PlacementP1\" (play (move (from (handSite P1)) (to (intersection (sites \"CentreSites\") (sites Empty))) (then (if (is Occupied (handSite P1)) (moveAgain))))) (nextPhase (is Empty (handSite P1)) \"PlacementP2\")) (phase \"PlacementP2\" (play (move (from (handSite P2)) (to (difference (sites Empty) (sites \"CentreSites\"))) (then (if (is Occupied (handSite P2)) (moveAgain))))) (nextPhase (is Empty (handSite P2)) \"Movement\")) (\"PhaseMovePiece\" \"Movement\" (end { (\"PieceTypeReachWin\" \"Commander1\" (sites Outer) P1) (if (\"IsOffBoard\" (where \"Commander\" P1)) (result P2 Win))}))}))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Objectives\n            One player has a gold fleet consisting of one large flagship and twelve escorts, with the objective of evading capture while breaking through his or her opponent's blockade to transport the flagship to the perimeter of the board. The other player has a silver fleet of twenty ships, and forms a blockade to trap the gold flagship and destroy the gold fleet's escorts with the objective of capturing the flagship.\n            \n            Setup\n            Gold player places the flagship on the center square of the game board, and positions the rest of the ships anywhere within the boldly ruled central area of the board.\n            \n            Silver player then positions the silver ships on twenty squares in the lightly ruled peripheral area of the board.\n            \n            Play\n            Gold player chooses who goes first. Players move alternately by making two moves or one capture anywhere on the board. When the flagship is moved, only one move or capture is made (thus only the flagship).\n            \n            Moves\n            A player may move two of the smaller playing pieces any number of vacant squares either horizontally or vertically on the board (as a rook in Chess, except that no captures can be made with this move), although if the flagship is moved, the gold player may not move another playing piece.\n            \n            Captures\n            A player may move any playing piece (including the flagship) one square diagonally to capture one of his opponent's playing pieces. (This move is similar to the capture-move of the pawn in Chess, except that captures can be made on any of the four diagonals.)\n            \n            This game uses displacement capture (like Chess), rather than custodial capture (like Hnefatafl), thus when a capture is made, the captured piece is removed from the board and the vacated square is occupied by the captor.\n            \n        Play continues until one player achieves his or her objective. If the flagship of the gold fleet reaches one of the outermost squares on the board, gold player wins. If the flagship is captured before it reaches the outer edge of the board, silver player wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(game \"Tic-Tac-Mo\" (players 3) (equipment { (board (rectangle 3 5)) (piece \"Disc\" P1) (piece \"Cross\" P2) (piece \"Y\" P3)}) (rules (play (move Add (to (sites Empty)))) (end (\"Line3Win\"))))\n\n### Response:\n",
    "completion": "Tic-Tac-Mo uses the same rules as Tic-Tac-Toe, but the third player plays with a \\ ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(game \"Tic-Tac-Mo\" (players 3) (equipment { (board (rectangle 3 5)) (piece \"Disc\" P1) (piece \"Cross\" P2) (piece \"Y\" P3)}) (rules (play (move Add (to (sites Empty)))) (end (\"Line3Win\"))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayers take turns placing a piece of each color in an empty site. Play ends at the start of the first players turn, if all the players would not be able to complete their turn. Example: for 2 players less than 4 empty sites.\n            \n        Scores are awarded based on the sizes of the groups of each color on the board, which are multiplied. The player with the highest score wins. The game is played on a 5x5 board The version of the game played with 2 players.\n\n### Response:\n",
    "completion": "(game \"Omega\" (players 2) (equipment { (board (hex 5)) (piece \"Marker\" Each)}) (rules (play (move Add (piece (+ 1 (% (count Moves) (count Players)))) (to (sites Empty)) (then (if (!= (count MovesThisTurn) (- (count Players) 1)) (moveAgain))))) (end (if (and { (not (is Mover P1)) (is Next P1) (> (pow (count Players) 2) (count Sites in:(sites Empty)))}) (byScore {(score P1 (* (sizes Group P1))) (score P2 (* (sizes Group P2)))})))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Players take turns placing a piece of each color in an empty site. Play ends at the start of the first players turn, if all the players would not be able to complete their turn. Example: for 2 players less than 4 empty sites.\n            \n        Scores are awarded based on the sizes of the groups of each color on the board, which are multiplied. The player with the highest score wins. The game is played on a 5x5 board The version of the game played with 2 players."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nEach row has 21 holes. -> Each row has 22 holes.\n\n### Input:\n(define \"PiecesOwnedBy\" (count Sites in:(sites Occupied by:#1))) (define \"AllPiecesInOpponentHome\" (and (= 0 (count Sites in:(difference (sites Occupied by:Team1) (sites P2 \"Home\")))) (= 0 (count Sites in:(difference (sites Occupied by:Team2) (sites P1 \"Home\")))))) (define \"Move\" (move (from (site)) (to (\"NextSiteOnTrack\" \"ThrowValue\") if:(and (or (is Empty (to)) (and (not (is In (to) (sites Next \"Home\"))) (\"IsEnemyAt\" (to)))) (\"NoFriendPieceInBetween\" #1)) \"CaptureEnemyPiece\"))) (define \"NoFriendPieceInBetween\" (= 1 (count Sites in:(intersection (sites Occupied by:#1) (sites Track Mover \"Track\" from:(from) to:(\"NextSiteOnTrack\" \"ThrowValue\")))))) (define \"CaptureEnemyPiece\" (apply if:(\"IsEnemyAt\" (to)) (remove (to)))) (define \"SpecialThrows\" (is In (\"ThrowValue\") (sites {1 4}))) (define \"ThrowValue\" (mapEntry (count Pips))) (game \"Sig (Western Sahara)\" (players 4) (equipment { (board (rectangle 4 21) { (track \"Track1\" \"0,E,N1,W,N1,E,N1,W\" P1 directed:True) (track \"Track2\" \"83,W,S1,E,S1,W,S1,E\" P2 directed:True) (track \"Track3\" \"0,E,N1,W,N1,E,N1,W\" P3 directed:True) (track \"Track4\" \"83,W,S1,E,S1,W,S1,E\" P4 directed:True)} use:Vertex) (piece \"Stick\" Each) (regions \"AllSites\" (sites Board)) (\"StickDice\" 8) (map \"Throw\" {(pair 0 8) (pair 1 1) (pair 2 6) (pair 3 5) (pair 4 4) (pair 5 5) (pair 6 6) (pair 7 1) (pair 8 8)}) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top)) (regions \"Home\" P3 (sites Bottom)) (regions \"Home\" P4 (sites Top))}) (rules (start { (set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place \"Stick1\" (sites Bottom)) (place \"Stick2\" (sites Top))}) (play (\"RollMove\" (if (or (is Mover P1) (is Mover P3)) (forEach Site (sites Occupied by:Team1) (\"Move\" Team1)) (forEach Site (sites Occupied by:Team2) (\"Move\" Team2))) (then (if (\"SpecialThrows\") (moveAgain))))) (end (if (\"AllPiecesInOpponentHome\") { (if (= (\"PiecesOwnedBy\" Team1) (\"PiecesOwnedBy\" Team2)) (result Mover Draw)) (if (< (\"PiecesOwnedBy\" Team1) (\"PiecesOwnedBy\" Team2)) (result Team2 Win)) (if (> (\"PiecesOwnedBy\" Team1) (\"PiecesOwnedBy\" Team2)) (result Team1 Win))}))))\n\n### Response:\n",
    "completion": "(define \"PiecesOwnedBy\" (count Sites in:(sites Occupied by:#1))) (define \"AllPiecesInOpponentHome\" (and (= 0 (count Sites in:(difference (sites Occupied by:Team1) (sites P2 \"Home\")))) (= 0 (count Sites in:(difference (sites Occupied by:Team2) (sites P1 \"Home\")))))) (define \"Move\" (move (from (site)) (to (\"NextSiteOnTrack\" \"ThrowValue\") if:(and (or (is Empty (to)) (and (not (is In (to) (sites Next \"Home\"))) (\"IsEnemyAt\" (to)))) (\"NoFriendPieceInBetween\" #1)) \"CaptureEnemyPiece\"))) (define \"NoFriendPieceInBetween\" (= 1 (count Sites in:(intersection (sites Occupied by:#1) (sites Track Mover \"Track\" from:(from) to:(\"NextSiteOnTrack\" \"ThrowValue\")))))) (define \"CaptureEnemyPiece\" (apply if:(\"IsEnemyAt\" (to)) (remove (to)))) (define \"SpecialThrows\" (is In (\"ThrowValue\") (sites {1 4}))) (define \"ThrowValue\" (mapEntry (count Pips))) (game \"Sig (Western Sahara)\" (players 4) (equipment { (board (rectangle 4 22) { (track \"Track1\" \"0,E,N1,W,N1,E,N1,W\" P1 directed:True) (track \"Track2\" \"87,W,S1,E,S1,W,S1,E\" P2 directed:True) (track \"Track3\" \"0,E,N1,W,N1,E,N1,W\" P3 directed:True) (track \"Track4\" \"87,W,S1,E,S1,W,S1,E\" P4 directed:True)} use:Vertex) (piece \"Stick\" Each) (regions \"AllSites\" (sites Board)) (\"StickDice\" 8) (map \"Throw\" {(pair 0 8) (pair 1 1) (pair 2 6) (pair 3 5) (pair 4 4) (pair 5 5) (pair 6 6) (pair 7 1) (pair 8 8)}) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top)) (regions \"Home\" P3 (sites Bottom)) (regions \"Home\" P4 (sites Top))}) (rules (start { (set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place \"Stick1\" (sites Bottom)) (place \"Stick2\" (sites Top))}) (play (\"RollMove\" (if (or (is Mover P1) (is Mover P3)) (forEach Site (sites Occupied by:Team1) (\"Move\" Team1)) (forEach Site (sites Occupied by:Team2) (\"Move\" Team2))) (then (if (\"SpecialThrows\") (moveAgain))))) (end (if (\"AllPiecesInOpponentHome\") { (if (= (\"PiecesOwnedBy\" Team1) (\"PiecesOwnedBy\" Team2)) (result Mover Draw)) (if (< (\"PiecesOwnedBy\" Team1) (\"PiecesOwnedBy\" Team2)) (result Team2 Win)) (if (> (\"PiecesOwnedBy\" Team1) (\"PiecesOwnedBy\" Team2)) (result Team1 Win))}))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nEach row has 21 holes. -> Each row has 22 holes.",
    "_var_input": "(define \"PiecesOwnedBy\" (count Sites in:(sites Occupied by:#1))) (define \"AllPiecesInOpponentHome\" (and (= 0 (count Sites in:(difference (sites Occupied by:Team1) (sites P2 \"Home\")))) (= 0 (count Sites in:(difference (sites Occupied by:Team2) (sites P1 \"Home\")))))) (define \"Move\" (move (from (site)) (to (\"NextSiteOnTrack\" \"ThrowValue\") if:(and (or (is Empty (to)) (and (not (is In (to) (sites Next \"Home\"))) (\"IsEnemyAt\" (to)))) (\"NoFriendPieceInBetween\" #1)) \"CaptureEnemyPiece\"))) (define \"NoFriendPieceInBetween\" (= 1 (count Sites in:(intersection (sites Occupied by:#1) (sites Track Mover \"Track\" from:(from) to:(\"NextSiteOnTrack\" \"ThrowValue\")))))) (define \"CaptureEnemyPiece\" (apply if:(\"IsEnemyAt\" (to)) (remove (to)))) (define \"SpecialThrows\" (is In (\"ThrowValue\") (sites {1 4}))) (define \"ThrowValue\" (mapEntry (count Pips))) (game \"Sig (Western Sahara)\" (players 4) (equipment { (board (rectangle 4 21) { (track \"Track1\" \"0,E,N1,W,N1,E,N1,W\" P1 directed:True) (track \"Track2\" \"83,W,S1,E,S1,W,S1,E\" P2 directed:True) (track \"Track3\" \"0,E,N1,W,N1,E,N1,W\" P3 directed:True) (track \"Track4\" \"83,W,S1,E,S1,W,S1,E\" P4 directed:True)} use:Vertex) (piece \"Stick\" Each) (regions \"AllSites\" (sites Board)) (\"StickDice\" 8) (map \"Throw\" {(pair 0 8) (pair 1 1) (pair 2 6) (pair 3 5) (pair 4 4) (pair 5 5) (pair 6 6) (pair 7 1) (pair 8 8)}) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top)) (regions \"Home\" P3 (sites Bottom)) (regions \"Home\" P4 (sites Top))}) (rules (start { (set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place \"Stick1\" (sites Bottom)) (place \"Stick2\" (sites Top))}) (play (\"RollMove\" (if (or (is Mover P1) (is Mover P3)) (forEach Site (sites Occupied by:Team1) (\"Move\" Team1)) (forEach Site (sites Occupied by:Team2) (\"Move\" Team2))) (then (if (\"SpecialThrows\") (moveAgain))))) (end (if (\"AllPiecesInOpponentHome\") { (if (= (\"PiecesOwnedBy\" Team1) (\"PiecesOwnedBy\" Team2)) (result Mover Draw)) (if (< (\"PiecesOwnedBy\" Team1) (\"PiecesOwnedBy\" Team2)) (result Team2 Win)) (if (> (\"PiecesOwnedBy\" Team1) (\"PiecesOwnedBy\" Team2)) (result Team1 Win))}))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayers take turns placing a piece of their colour at an empty cell, and win by connecting their board sides with a chain of their pieces. The game is played on a 11x11 board. The game uses the swap rule. The first player to connect their two sides wins.\n\n### Response:\n",
    "completion": "(game \"Hex\" (players 2) (equipment { (board (hex Diamond 11)) (piece \"Marker\" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Connected Mover) (result Mover Win)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Players take turns placing a piece of their colour at an empty cell, and win by connecting their board sides with a chain of their pieces. The game is played on a 11x11 board. The game uses the swap rule. The first player to connect their two sides wins."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nSnipSnip is a 2-player strategy game\n            It may be played: \n            -- on a hex grid\n            -- on a square grid\n            -- on a square plus diagonal grid\n            Goal: Largest Group (in Misere, the largest Group loses.)\n            \n            Definitions:\n            A Group is a set of all the pieces that can be reached from any one of them by a series of steps, where a step means movement from one piece to another of the same color, next to it.\n            \n            Note: For the Diagonal-Linked Group options a step also include diagonals (double-steps that are not in the same grid direction).\n            \n            A site is a board intersection.\n            \n            'Between' Variant:\n            -- A Capture site is any site adjacent to two stones of opposite color in the same line (i.e. directly between them.)\n            \n            'Diagonal' Variant:\n            -- A Capture site is any site adjacent to each of two stones of opposite color, where those stones are not on the same grid-line.\n            \n            Play:\n            Players take turn, starting on an empty board with White to play.\n            \n            On a turn\n        1) The mover places to an empty site that is not a Capture site.\n    2) Then, if possible, the mover removes one of the opponent's checkers from a Capture site that lies adjacent to the placement just made.\n    \n    In the case of Misere, the mover must take an additional turn after each capture.\n    \n    Otherwise, the next player becomes the mover.\n    \n    The game ends when no placement is possible.\nIn the case of a tie, the player who would have been next to place loses. Misere: Score one negative point for each stone in your largest group of adjacent stones Capture one of the opponent's stones on the 2  sites orthogonally between your stone and a diagonally adjacent opponent's stone. Board & size: Equiversi Hexhex with edges alternating 2 and 4\n\n### Response:\n",
    "completion": "(define \"HighlightConnections\" (show Symbol \"Disc.svg\" Vertex (\"DiagonallyConnectedDomainsOf\" 2) fillColour:(colour 0 0 255 50) edgeColour:(colour 0 0 0 0) scale:1) (show Symbol \"Disc.svg\" Vertex (\"DiagonallyConnectedDomainsOf\" 1) fillColour:(colour 255 255 0 100) edgeColour:(colour 0 0 0 0) scale:1)) (define \"Tri78Bug\" (tri {7 8 7 10 6})) (define \"Tri57Bug\" (tri {5 7 5 8 5})) (define \"Tri56Bug\" (tri {5 6 5 7 5})) (define \"Tri46Bug\" (tri {4 6 4 7 4})) (define \"Misere\" -1) (define \"Sites2RemoveBetween\" (forEach of:(sites Distance (step (to if:(is Next (who at:(to))))) from:(last To) (exact 2)) (sites Between Orthogonal from:(last To) to:(site) cond:(is In (between) (sites Occupied by:#1))))) (define \"SitesAllowedBetween\" (difference (sites Empty) (sites (results from:(sites Occupied by:P1) to:(forEach of:(sites Distance Orthogonal from:(from) (exact 2)) (sites Between Orthogonal from:(from) to:(site) cond:(and (is In (site) (sites Occupied by:P2)) (is Empty (between))))) (to))))) (define \"Sites2RemoveDiagonal\" (sites (results from:(last To) to:(forEach of:(intersection \"SitesAtOmniDiagonal\" (sites Occupied by:#1)) (intersection { (sites Around (from) Orthogonal) (sites Around (site) Orthogonal) (sites Occupied by:#1)})) (to)))) (define \"SitesAllowedDiagonal\" (difference (sites Empty) (sites (results from:(sites Occupied by:P1) to:(forEach of:(intersection \"SitesAtOmniDiagonal\" (sites Occupied by:P2)) (intersection { (sites Around (from) Orthogonal) (sites Around (site) Orthogonal) (sites Empty)})) (to))))) (define \"SetPairScores\" (forEach Player (set Score (player (player)) (* #1 (/ (+ (results from:(sites Occupied by:(player (player))) to:(sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:(player (player))))) 1)) 2))))) (define \"SetGroupScores\" (forEach Player (set Score (player (player)) (* #1 (max 0 (max (sizes Group Orthogonal of:(player)))))))) (define \"SetStoneScores\" (set Score P1 (* #1 (count Pieces P1)) (then (set Score P2 (* #1 (count Pieces P2)))))) (define \"SetDiagonalGroupScores\" (forEach Player (set Score (player (player)) (* #1 (max 0 (+ 1 (max (results from:(sites Occupied by:(player (player))) to:(from) (size Array (array (intersection (sites Distance Orthogonal (step Orthogonal (to if:(is In (to) (\"DiagonallyConnectedDomainsOf\" (player))))) from:(from) (min 0)) (sites Occupied by:(player (player)))))))))))))) (define \"DiagonallyConnectedDomainsOf\" (union (sites Occupied by:(player #1)) (sites (results from:(sites Occupied by:(player #1)) to:(intersection (sites Occupied by:(player #1)) \"SitesAtOmniDiagonal\") (regionSite (intersection (sites Around (from) Orthogonal) (sites Around (to) Orthogonal)) index:0))))) (define \"SitesAtOmniDiagonal\" (difference (difference (sites Around (sites Around (from) Orthogonal) Orthogonal) (sites (from) {{F} {F F}})) (from))) (game \"SnipSnip\" (players 2) (equipment { (board (tri {2 4 2 4 2}) use:Vertex) (piece \"Ball\" Each)}) (rules (start { (set Score Each 0)}) (play (if (= 1 (value Player Mover)) (move Remove (\"Sites2RemoveDiagonal\" Next) (then (and { (set Value Mover 0) (moveAgain)}))) (move Add (to (\"SitesAllowedDiagonal\")) (then (if (< 0 (count Pieces in:(\"Sites2RemoveDiagonal\" Next))) (set Value Mover 1 (then (moveAgain)))))) (then (\"SetGroupScores\" \"Misere\")))) (end { (if (and (no Moves Next) (= (score P1) (score P2))) (result Next Loss)) (if (and (no Moves Next) (!= (score P1) (score P2))) (byScore))})))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "SnipSnip is a 2-player strategy game\n            It may be played: \n            -- on a hex grid\n            -- on a square grid\n            -- on a square plus diagonal grid\n            Goal: Largest Group (in Misere, the largest Group loses.)\n            \n            Definitions:\n            A Group is a set of all the pieces that can be reached from any one of them by a series of steps, where a step means movement from one piece to another of the same color, next to it.\n            \n            Note: For the Diagonal-Linked Group options a step also include diagonals (double-steps that are not in the same grid direction).\n            \n            A site is a board intersection.\n            \n            'Between' Variant:\n            -- A Capture site is any site adjacent to two stones of opposite color in the same line (i.e. directly between them.)\n            \n            'Diagonal' Variant:\n            -- A Capture site is any site adjacent to each of two stones of opposite color, where those stones are not on the same grid-line.\n            \n            Play:\n            Players take turn, starting on an empty board with White to play.\n            \n            On a turn\n        1) The mover places to an empty site that is not a Capture site.\n    2) Then, if possible, the mover removes one of the opponent's checkers from a Capture site that lies adjacent to the placement just made.\n    \n    In the case of Misere, the mover must take an additional turn after each capture.\n    \n    Otherwise, the next player becomes the mover.\n    \n    The game ends when no placement is possible.\nIn the case of a tie, the player who would have been next to place loses. Misere: Score one negative point for each stone in your largest group of adjacent stones Capture one of the opponent's stones on the 2  sites orthogonally between your stone and a diagonally adjacent opponent's stone. Board & size: Equiversi Hexhex with edges alternating 2 and 4"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThe first capture must be of one counter. The first capture must be of three counters, the second of one counter.\n\n### Response:\n",
    "completion": "(define \"PiecesOwnedBy\" (+ (count at:(mapEntry #1)) (count in:(sites #1)))) (define \"Sow\" (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow #1 if:(or { (and {(<= (count at:(to)) 9) (is Odd (count at:(to))) (>= \"NumCaptureDone\" 2)}) (and (\"IsOffBoard\" \"NumCaptureDone\") (= (count at:(to)) 3)) (and (= \"NumCaptureDone\" 1) (= (count at:(to)) 1))}) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to)) (then (and (if (= \"NumCaptureDone\" 1) (set Value Mover 2)) (if (\"IsOffBoard\" \"NumCaptureDone\") (set Value Mover 1))))) origin:True)))) (define \"NumCaptureDone\" (value Player Mover)) (game \"Ako Okwe\" (players 2) (equipment { (mancalaBoard 2 5 { (track \"TrackCCW\" \"1,E,N,W\" loop:True) (track \"TrackCW\" \"6,E,S,W\" loop:True)}) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece \"Seed\" Shared)}) (rules (start (set Count 10 to:(sites Track))) (play (or (\"Sow\" \"TrackCW\") (\"Sow\" \"TrackCCW\"))) (end (\"MancalaByScoreWhen\" (no Moves Mover)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "The first capture must be of one counter. The first capture must be of three counters, the second of one counter."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nThe game starts with 3 discs for the second player. -> The game starts with 4 discs for the second player.\n\n### Input:\n(game \"Kaooa\" (players 2) (equipment { (\"StarBoard\" 5) (hand Each) (piece \"Marker\" P1 (or (\"HopSequenceCapture\") \"StepToEmpty\")) (piece \"Marker\" P2 \"StepToEmpty\")}) (rules (start { (place \"Marker1\" (handSite P1) count:1) (place \"Marker2\" (handSite P2) count:3)}) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (\"HandEmpty\" Mover) \"Movement\")) (\"PhaseMovePiece\" \"Movement\" (end (\"NoMoves\" Loss)))}))\n\n### Response:\n",
    "completion": "(game \"Kaooa\" (players 2) (equipment { (\"StarBoard\" 5) (hand Each) (piece \"Marker\" P1 (or (\"HopSequenceCapture\") \"StepToEmpty\")) (piece \"Marker\" P2 \"StepToEmpty\")}) (rules (start { (place \"Marker1\" (handSite P1) count:1) (place \"Marker2\" (handSite P2) count:4)}) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (\"HandEmpty\" Mover) \"Movement\")) (\"PhaseMovePiece\" \"Movement\" (end (\"NoMoves\" Loss)))}))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nThe game starts with 3 discs for the second player. -> The game starts with 4 discs for the second player.",
    "_var_input": "(game \"Kaooa\" (players 2) (equipment { (\"StarBoard\" 5) (hand Each) (piece \"Marker\" P1 (or (\"HopSequenceCapture\") \"StepToEmpty\")) (piece \"Marker\" P2 \"StepToEmpty\")}) (rules (start { (place \"Marker1\" (handSite P1) count:1) (place \"Marker2\" (handSite P2) count:3)}) phases:{ (phase \"Placement\" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (\"HandEmpty\" Mover) \"Movement\")) (\"PhaseMovePiece\" \"Movement\" (end (\"NoMoves\" Loss)))}))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nChecks if a level is at the top of a stack.\n\n### Response:\n",
    "completion": "(define \"IsTopLevel\" (= (topLevel at:#1) (level)))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Checks if a level is at the top of a stack."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(define \"EmptyOrFriednIfNotSpecialRegion\" (and (not (is In (to) (sites Mover \"OnePieceMax\"))) (or (\"IsFriendAt\" (to)) (is Empty (to))))) (define \"OneEnemyPiece\" (and (\"IsSingletonStack\" (to)) (\"IsEnemyAt\" (to)))) (define \"CaptureEnemyPiece\" (if (\"IsEnemyAt\" (to)) (move (from (to)) (to (\"BarSite\" Next))))) (define \"EmptySiteIfOneSpecialRegion\" (and (is Empty (to)) (is In (to) (sites Mover \"OnePieceMax\")))) (define \"BarSite\" (mapEntry \"Bar\" #1)) (define \"BarEmpty\" (is Empty (\"BarSite\" #1))) (define \"SiteToMoveOnTrack\" (trackSite Move steps:(pips))) (define \"RemoveAPiece\" (move Remove (from))) (define \"SiteToEnterCapturePiece\" (\"NextSiteOnTrack\" (pips) from:(\"BarSite\" Mover))) (define \"SiteToEnter\" (\"NextSiteOnTrack\" (pips) from:(mapEntry \"StartTrack\" Mover))) (game \"Tawula\" (players 2) (equipment { (\"BackgammonBoard\" \"BackgammonTracksSameDirectionOppositeCornersWithBars2\") (dice d:6 num:2) (piece \"Disc\" Each (if (or (!= (from) (mapEntry \"StartTrack\" Mover)) (and (= (from) (mapEntry \"StartTrack\" Mover)) (\"HandEmpty\" Mover))) (forEach Die if:(\"DieNotUsed\") (if (\"IsOffBoard\" \"SiteToMoveOnTrack\") \"RemoveAPiece\" (move (from) (to \"SiteToMoveOnTrack\" if:(or (or (\"EmptySiteIfOneSpecialRegion\") (\"EmptyOrFriednIfNotSpecialRegion\")) (\"OneEnemyPiece\")) (apply (\"CaptureEnemyPiece\")))))))) (hand Each) (map \"Bar\" {(pair P1 6) (pair P2 19)}) (map \"StartTrack\" {(pair P1 25) (pair P2 0)}) (regions \"OnePieceMax\" P1 (sites {14..18 20..24})) (regions \"OnePieceMax\" P2 (sites {1..5 7..11}))}) (rules (start { (place Stack \"Disc1\" 25 count:2) (place Stack \"Disc2\" 0 count:2) (place Stack \"Disc1\" (handSite P1) count:13) (place Stack \"Disc2\" (handSite P2) count:13)}) (play (\"RollEachNewTurnMove\" (or (if (\"BarEmpty\" Mover) (forEach Piece top:True) (forEach Die if:(\"DieNotUsed\") (move (from (\"BarSite\" Mover)) (to (\"SiteToEnterCapturePiece\") if:(or (or (\"EmptySiteIfOneSpecialRegion\") (\"EmptyOrFriednIfNotSpecialRegion\")) (\"OneEnemyPiece\")) (apply (\"CaptureEnemyPiece\")))))) (if (\"HandOccupied\" Mover) (forEach Die if:(\"DieNotUsed\") (move (from (handSite Mover)) (to (\"SiteToEnter\") if:(or (is Empty (to)) (\"OneEnemyPiece\")) (apply (\"CaptureEnemyPiece\")))))) (then (\"ReplayNotAllDiceUsed\"))))) (end (\"EscapeWin\"))))\n\n### Response:\n",
    "completion": "The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; both players progress in an anti-clockwise direction. Fifteen pieces per player, two six-sided dice. Each player begins with two pieces on the rightmost point on the opposite side of the board. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Further pieces are entered based on the roll of the dice, the point after the one with the two pieces on it at the beginning being counted as the first point. When entering captured pieces, however, the point where the two pieces start is counted as the first point. The two pieces which start on the board cannot be moved until all of the remaining pieces have been entered on the board. No more than one piece may rest on a point on the first half of the board, except for the two which start and also on the leftmost point on the opposite side of the board from where the player sits. When a piece lands on a point occupied by an opponent's piece, the opponent's piece is removed from the board and must be entered again. Players must enter captured pieces before continuing to move the other pieces on the board. When a piece is captured in the opponent's starting quadrant, a point must be left open or with only one piece, thus allowing the opponent to enter their piece. The player to move all of their pieces off the board wins.\n         ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(define \"EmptyOrFriednIfNotSpecialRegion\" (and (not (is In (to) (sites Mover \"OnePieceMax\"))) (or (\"IsFriendAt\" (to)) (is Empty (to))))) (define \"OneEnemyPiece\" (and (\"IsSingletonStack\" (to)) (\"IsEnemyAt\" (to)))) (define \"CaptureEnemyPiece\" (if (\"IsEnemyAt\" (to)) (move (from (to)) (to (\"BarSite\" Next))))) (define \"EmptySiteIfOneSpecialRegion\" (and (is Empty (to)) (is In (to) (sites Mover \"OnePieceMax\")))) (define \"BarSite\" (mapEntry \"Bar\" #1)) (define \"BarEmpty\" (is Empty (\"BarSite\" #1))) (define \"SiteToMoveOnTrack\" (trackSite Move steps:(pips))) (define \"RemoveAPiece\" (move Remove (from))) (define \"SiteToEnterCapturePiece\" (\"NextSiteOnTrack\" (pips) from:(\"BarSite\" Mover))) (define \"SiteToEnter\" (\"NextSiteOnTrack\" (pips) from:(mapEntry \"StartTrack\" Mover))) (game \"Tawula\" (players 2) (equipment { (\"BackgammonBoard\" \"BackgammonTracksSameDirectionOppositeCornersWithBars2\") (dice d:6 num:2) (piece \"Disc\" Each (if (or (!= (from) (mapEntry \"StartTrack\" Mover)) (and (= (from) (mapEntry \"StartTrack\" Mover)) (\"HandEmpty\" Mover))) (forEach Die if:(\"DieNotUsed\") (if (\"IsOffBoard\" \"SiteToMoveOnTrack\") \"RemoveAPiece\" (move (from) (to \"SiteToMoveOnTrack\" if:(or (or (\"EmptySiteIfOneSpecialRegion\") (\"EmptyOrFriednIfNotSpecialRegion\")) (\"OneEnemyPiece\")) (apply (\"CaptureEnemyPiece\")))))))) (hand Each) (map \"Bar\" {(pair P1 6) (pair P2 19)}) (map \"StartTrack\" {(pair P1 25) (pair P2 0)}) (regions \"OnePieceMax\" P1 (sites {14..18 20..24})) (regions \"OnePieceMax\" P2 (sites {1..5 7..11}))}) (rules (start { (place Stack \"Disc1\" 25 count:2) (place Stack \"Disc2\" 0 count:2) (place Stack \"Disc1\" (handSite P1) count:13) (place Stack \"Disc2\" (handSite P2) count:13)}) (play (\"RollEachNewTurnMove\" (or (if (\"BarEmpty\" Mover) (forEach Piece top:True) (forEach Die if:(\"DieNotUsed\") (move (from (\"BarSite\" Mover)) (to (\"SiteToEnterCapturePiece\") if:(or (or (\"EmptySiteIfOneSpecialRegion\") (\"EmptyOrFriednIfNotSpecialRegion\")) (\"OneEnemyPiece\")) (apply (\"CaptureEnemyPiece\")))))) (if (\"HandOccupied\" Mover) (forEach Die if:(\"DieNotUsed\") (move (from (handSite Mover)) (to (\"SiteToEnter\") if:(or (is Empty (to)) (\"OneEnemyPiece\")) (apply (\"CaptureEnemyPiece\")))))) (then (\"ReplayNotAllDiceUsed\"))))) (end (\"EscapeWin\"))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(game \"Rimau-Rimau (Two Tigers)\" (players 2) (equipment { (\"AlquerqueBoardWithBottomAndTopTriangles\") (hand Each) (piece \"Tiger\" P1 (or { (\"StepToEmpty\") (\"HopCapture\")})) (piece \"human\" P2 \"StepToEmpty\")}) (rules (start { (place \"human2\" (difference (expand (sites Centre)) (centrePoint))) (place \"human2\" (handSite P2) count:16) (place \"Tiger1\" (handSite P1) count:2)}) phases:{ (phase \"PlacementFirstTiger\" P1 (play (move (from (handSite P1)) (to (sites Empty)) (then (moveAgain)))) (nextPhase Mover \"RemoveHuman\")) (phase \"RemoveHuman\" P1 (play (move Remove (intersection (sites Board) (sites Occupied by:Next)) (then (moveAgain)))) (nextPhase Mover \"PlacementSecondTiger\")) (phase \"PlacementSecondTiger\" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase Mover \"Movement\")) (phase \"PlacementHuman\" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (\"HandEmpty\" P2) \"Movement\")) (\"PhaseMovePiece\" \"Movement\" (end { (if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))}))\n\n### Response:\n",
    "completion": "5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. One player plays as two tigers, the other as 23 people. One of the tigers begins on any spot on the board. Eight of the people begin on the spots surrounding the central point of the board. The tiger player, on their first turn, removes one of the people and then places the second tiger anywhere on the board. The people then play, placing one of the remaining people on an empty spot on the board. On the tiger's turn, the player may move one of the tigers to an empty adjacent spot along the lines of the board. The tiger may also capture a person by hopping over it to an empty adjacent spot immediately on the opposite side of it along the lines of the board. When all of the people are placed, they move to an empty adjacent spot along the lines of the board on their turn. The tigers win by capturing all the people; the people win by blocking both tigers from being able to move. The two tigers start in the hand.",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(game \"Rimau-Rimau (Two Tigers)\" (players 2) (equipment { (\"AlquerqueBoardWithBottomAndTopTriangles\") (hand Each) (piece \"Tiger\" P1 (or { (\"StepToEmpty\") (\"HopCapture\")})) (piece \"human\" P2 \"StepToEmpty\")}) (rules (start { (place \"human2\" (difference (expand (sites Centre)) (centrePoint))) (place \"human2\" (handSite P2) count:16) (place \"Tiger1\" (handSite P1) count:2)}) phases:{ (phase \"PlacementFirstTiger\" P1 (play (move (from (handSite P1)) (to (sites Empty)) (then (moveAgain)))) (nextPhase Mover \"RemoveHuman\")) (phase \"RemoveHuman\" P1 (play (move Remove (intersection (sites Board) (sites Occupied by:Next)) (then (moveAgain)))) (nextPhase Mover \"PlacementSecondTiger\")) (phase \"PlacementSecondTiger\" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase Mover \"Movement\")) (phase \"PlacementHuman\" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (\"HandEmpty\" P2) \"Movement\")) (\"PhaseMovePiece\" \"Movement\" (end { (if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))}))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(define \"PiecesOwnedBy\" (count at:(mapEntry #1))) (define \"NextHoleFrom\" (\"NextSiteOnTrack\" #3 from:#1 #2)) (game \"Kay\" (players 2) (equipment { (mancalaBoard 2 6 (track \"Track\" \"1,E,N,W\" loop:True)) (piece \"Seed\" Shared) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (\"SameTurn\") \"LastHoleSowed\" (sites Mover)) if:(or (< 1 (count at:(from))) (and (= 1 (count at:(from))) (is Empty (\"NextHoleFrom\" (from) \"Track\" 1))))) (then (sow if:True apply:(if (= 4 (count at:(to))) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (< 1 (count at:(to))) (if (is Occupied (\"NextHoleFrom\" (to) \"Track\" 1)) (moveAgain)))) includeSelf:False backtracking:(= 4 (count at:(to))))))) (end (\"MancalaByScoreWhen\" (no Moves Next)))))\n\n### Response:\n",
    "completion": "2x6 board, one store on either end. Four counters in each hole. Sowing occurs in an anti-clockwise direction and begins in the player's row. When the final counter lands in an occupied hole which is not followed by an empty hole, the contents are picked up and sowing continues. If the final counter falls in an occupied hole followed by an empty hole, or if it falls into an empty hole, the turn ends. Sowing always skips the hole from which the sowing began if it goes all the way around the board. When the final counter falls into an occupied hole in the opponent's row containing three counters, these are captured and the turn ends. Any holes in the opponent's row containing four counters in an unbroken consecutive sequence behind this hole are also captured. Single counters can only be sowed when the next hole is empty. Play continues until one player can no longer play. The player who has captured the most counters wins. ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(define \"PiecesOwnedBy\" (count at:(mapEntry #1))) (define \"NextHoleFrom\" (\"NextSiteOnTrack\" #3 from:#1 #2)) (game \"Kay\" (players 2) (equipment { (mancalaBoard 2 6 (track \"Track\" \"1,E,N,W\" loop:True)) (piece \"Seed\" Shared) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (\"SameTurn\") \"LastHoleSowed\" (sites Mover)) if:(or (< 1 (count at:(from))) (and (= 1 (count at:(from))) (is Empty (\"NextHoleFrom\" (from) \"Track\" 1))))) (then (sow if:True apply:(if (= 4 (count at:(to))) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (< 1 (count at:(to))) (if (is Occupied (\"NextHoleFrom\" (to) \"Track\" 1)) (moveAgain)))) includeSelf:False backtracking:(= 4 (count at:(to))))))) (end (\"MancalaByScoreWhen\" (no Moves Next)))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nDefines starting rules placing one counter on each white cell of a square board (e.g. Starting rules of Draughts).\n\n### Response:\n",
    "completion": "(define \"WhiteCellsSetup\" (start { (place \"Counter1\" (difference (expand (sites Bottom) steps:(- #1 1)) (sites Phase 0))) (place \"Counter2\" (difference (expand (sites Top) steps:(- #1 1)) (sites Phase 0)))}))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Defines starting rules placing one counter on each white cell of a square board (e.g. Starting rules of Draughts)."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThe objective of Cannon is to capture or shoot the opponent's Town.\n            \n            The player also wins the game if his opponent doesn't have legal moves.\n            \n            Players move alternately. On their first turns both players put a special piece called \\ \n\n### Response:\n",
    "completion": "(define \"CannonShoot\" (forEach Direction All (if (and { (\"IsCannon\") (is Empty (\"AheadSite\" steps:3))}) (if (\"IsEnemyAt\" (\"AheadSite\" steps:4)) (move Remove (\"AheadSite\" steps:4)) (if (and (is Empty (\"AheadSite\" steps:4)) (\"IsEnemyAt\" (\"AheadSite\" steps:5))) (move Remove (\"AheadSite\" steps:5))))))) (define \"IsCannon\" (and (\"IsPieceAt\" \"Pawn\" Mover (to)) (\"IsPieceAt\" \"Pawn\" Mover (\"AheadSite\" steps:2)))) (define \"AheadSite\" (ahead (from) #1 (directions Vertex from:(from) to:(to)))) (define \"CannonMove\" (move Hop All (between (exact 2) if:(\"IsPieceAt\" \"Pawn\" Mover (between))) (to if:(is Empty (to))))) (define \"RetreatMove\" (if (\"EnemyAround\") (move Hop (directions Backwards of:All) (between if:(is Empty (between))) (to if:(is Empty (to)))))) (define \"EnemyAround\" (not (all Sites (sites Around (from) All) if:(not (\"IsEnemyAt\" (site)))))) (define \"StepCapture\" (\"StepToEnemy\" (directions {Forwards Rightward Leftward} of:All))) (define \"StepToEmptyForwards\" (\"StepToEmpty\" (directions Forwards of:All))) (game \"Cannon\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 10) use:Vertex) (piece \"Pawn\" Each (or { (\"StepToEmptyForwards\") (\"StepCapture\") (\"RetreatMove\") (\"CannonMove\") (\"CannonShoot\")})) (piece \"Town\" Each) (hand Each) (regions \"Home\" P1 (sites Bottom)) (regions \"Home\" P2 (sites Top))}) (rules (start { (place \"Town\" \"Hand\") (place \"Pawn1\" (forEach (difference (expand (sites Row 2)) (sites Right)) if:(is Even (column of:(site))))) (place \"Pawn2\" (forEach (difference (expand (sites Row 7)) (sites Left)) if:(is Odd (column of:(site)))))}) phases:{ (phase \"Placing\" (play (move (from (handSite Mover)) (to (difference (sites Mover \"Home\") (sites Corners))))) (nextPhase Mover \"Moving\")) (phase \"Moving\" (play (forEach Piece)) (end (if (or (\"IsOffBoard\" (where \"Town\" Next)) (no Moves Next)) (result Mover Win))))}))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "The objective of Cannon is to capture or shoot the opponent's Town.\n            \n            The player also wins the game if his opponent doesn't have legal moves.\n            \n            Players move alternately. On their first turns both players put a special piece called \\ "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nThe game is played on a 10x10 board. -> The game is played on a 14x14 board.\n\n### Input:\n(game \"Hex\" (players 2) (equipment { (board (hex Diamond 10)) (piece \"Marker\" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Connected Mover) (result Mover Win)))))\n\n### Response:\n",
    "completion": "(game \"Hex\" (players 2) (equipment { (board (hex Diamond 14)) (piece \"Marker\" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Connected Mover) (result Mover Win)))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nThe game is played on a 10x10 board. -> The game is played on a 14x14 board.",
    "_var_input": "(game \"Hex\" (players 2) (equipment { (board (hex Diamond 10)) (piece \"Marker\" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Connected Mover) (result Mover Win)))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nChess rooks are added to the game. -> Chess knights are added to the game.\n\n### Input:\n(define \"InitialPawnMove\" (if (is In (from) (sites Start (piece (what at:(from))))) (\"DoubleStepForwardToEmpty\" \"SetEnPassantLocation\"))) (define \"EnPassant\" (move Step (directions {FR FL}) (to if:\"InLocationEnPassant\") (then (remove (ahead (last To) Backward))))) (define \"InLocationEnPassant\" (and (is Pending) (= (to) (value Pending)))) (define \"SetEnPassantLocation\" (then (set Pending (ahead (last To) Backward)))) (game \"The Pawn Game\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (\"ChessPawn\" \"Pawn\" (or \"InitialPawnMove\" \"EnPassant\")) (\"ChessRook\" \"Rook\") (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (sites Row 1)) (place \"Pawn2\" (sites Row 6)) (place \"Rook1\" {\"A1\" \"H1\"}) (place \"Rook2\" {\"A8\" \"H8\"})}) (play (forEach Piece)) (end { (\"ReachWin\" (sites Mover) Mover) (\"BlockWin\")})))\n\n### Response:\n",
    "completion": "(define \"InitialPawnMove\" (if (is In (from) (sites Start (piece (what at:(from))))) (\"DoubleStepForwardToEmpty\" \"SetEnPassantLocation\"))) (define \"EnPassant\" (move Step (directions {FR FL}) (to if:\"InLocationEnPassant\") (then (remove (ahead (last To) Backward))))) (define \"InLocationEnPassant\" (and (is Pending) (= (to) (value Pending)))) (define \"SetEnPassantLocation\" (then (set Pending (ahead (last To) Backward)))) (game \"The Pawn Game\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (\"ChessPawn\" \"Pawn\" (or \"InitialPawnMove\" \"EnPassant\")) (\"ChessKnight\" \"Knight\") (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (sites Row 1)) (place \"Pawn2\" (sites Row 6)) (place \"Knight1\" {\"B1\" \"G1\"}) (place \"Knight2\" {\"B8\" \"G8\"})}) (play (forEach Piece)) (end { (\"ReachWin\" (sites Mover) Mover) (\"BlockWin\")})))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nChess rooks are added to the game. -> Chess knights are added to the game.",
    "_var_input": "(define \"InitialPawnMove\" (if (is In (from) (sites Start (piece (what at:(from))))) (\"DoubleStepForwardToEmpty\" \"SetEnPassantLocation\"))) (define \"EnPassant\" (move Step (directions {FR FL}) (to if:\"InLocationEnPassant\") (then (remove (ahead (last To) Backward))))) (define \"InLocationEnPassant\" (and (is Pending) (= (to) (value Pending)))) (define \"SetEnPassantLocation\" (then (set Pending (ahead (last To) Backward)))) (game \"The Pawn Game\" (\"TwoPlayersNorthSouth\") (equipment { (board (square 8)) (\"ChessPawn\" \"Pawn\" (or \"InitialPawnMove\" \"EnPassant\")) (\"ChessRook\" \"Rook\") (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start { (place \"Pawn1\" (sites Row 1)) (place \"Pawn2\" (sites Row 6)) (place \"Rook1\" {\"A1\" \"H1\"}) (place \"Rook2\" {\"A8\" \"H8\"})}) (play (forEach Piece)) (end { (\"ReachWin\" (sites Mover) Mover) (\"BlockWin\")})))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThree vertical lines, and two horizontal lines intersecting them along their top end points and their midpoints. The ends of the lines which are not connected to one another are the calves' pens. Three pieces per player, one playing as calves (black), and the other as guardians (white), arranged on the intersections of opposite vertical lines. Players alternate turns moving one of their pieces to an adjacent spot. The guardians attempt to trap the calves into the three pens, the calves attempt to block the guardians from being able to move. \n\n### Response:\n",
    "completion": "(define \"AllCowsInBottom\" (all Sites (difference (sites Occupied by:P2) (sites Bottom)) if:(= 0 (count at:(site))))) (game \"Gurvan Xudag\" (players 2) (equipment { (board (remove (square 3) edges:{{0 1}{1 2}}) use:Vertex) (piece \"Human\" P1 \"StepToEmpty\") (piece \"Cow\" P2 \"StepToEmpty\")}) (rules (start { (place \"Human1\" (sites Left)) (place \"Cow2\" (sites Right))}) (play (forEach Piece)) (end { (if (no Moves P1) (result P2 Win)) (if (and (\"AllCowsInBottom\") (no Moves P2)) (result P1 Win))})))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Three vertical lines, and two horizontal lines intersecting them along their top end points and their midpoints. The ends of the lines which are not connected to one another are the calves' pens. Three pieces per player, one playing as calves (black), and the other as guardians (white), arranged on the intersections of opposite vertical lines. Players alternate turns moving one of their pieces to an adjacent spot. The guardians attempt to trap the calves into the three pens, the calves attempt to block the guardians from being able to move. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n8x8 board. Twelve pieces per player. Pieces move forward diagonally to an empty space on the board. A piece may capture an opponent's adjacent piece by hopping over it to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. Captures can be made in a forward or backward direction. Captures are compulsory, but it is not required to choose a capture sequence that captures the most pieces. A piece which reaches the opposite edge of the board from where it started is promoted to a king. Kings move any number of spaces forward or backward. They also may capture a single piece if there is at least one empty space beyond it, and can change direction after a capture. Kings must also make all possible captures in a sequence. The player who captures all of the opponent's pieces wins. \n\n### Response:\n",
    "completion": "(define \"IsUnpromoted\" (\"IsPieceAt\" \"Counter\" Mover (last To))) (game \"American Pool Checkers\" (players 2) (\"DraughtsEquipment\" (square 8)) (rules (\"BlackCellsSetup\" 3) (play (if \"SameTurn\" (if \"IsUnpromoted\" (\"HopInternationalDraughtsStyle\" (from (last To)) (then (\"ReplayIfCanMove\" (\"HopInternationalDraughtsStyle\" (from (last To))) (\"PromoteIfReach\" (sites Next) \"DoubleCounter\")))) (max Moves (\"HopDiagonalSequenceCaptureAgain\" before:(count Rows) after:(count Rows) at:EndOfTurn))) (priority { (or (forEach Piece \"Counter\" (\"HopInternationalDraughtsStyle\" (from) (then (\"ReplayIfCanMove\" (\"HopInternationalDraughtsStyle\" (from (last To))) (\"PromoteIfReach\" (sites Next) \"DoubleCounter\"))))) (max Moves (forEach Piece \"DoubleCounter\" (\"HopDiagonalSequenceCapture\" before:(count Rows) after:(count Rows) at:EndOfTurn)))) (or (forEach Piece \"Counter\" (\"StepToEmpty\" (directions {FR FL})) (then (\"PromoteIfReach\" (sites Next) \"DoubleCounter\"))) (forEach Piece \"DoubleCounter\" (move Slide Diagonal)))}))) (end (\"BlockWin\"))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "8x8 board. Twelve pieces per player. Pieces move forward diagonally to an empty space on the board. A piece may capture an opponent's adjacent piece by hopping over it to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. Captures can be made in a forward or backward direction. Captures are compulsory, but it is not required to choose a capture sequence that captures the most pieces. A piece which reaches the opposite edge of the board from where it started is promoted to a king. Kings move any number of spaces forward or backward. They also may capture a single piece if there is at least one empty space beyond it, and can change direction after a capture. Kings must also make all possible captures in a sequence. The player who captures all of the opponent's pieces wins. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nThree-row board, outer rows with sixteen holes and the central with seventeen. Sixteen pieces per player, which start the board in each of the holes in the outer row belonging to a player. Two four-sided dice. Players move their pieces according to the throws of the dice, moving one piece the value of one of the dice and another the value of the other die, or one piece the value of both dice. Players move from their row into the central row, and when reaching the end of the central row, proceed into the opponent's row. Opponent's pieces are taken when a player's piece lands in the same spot as the opponent's piece. Players may not move one of their pieces past one of their other pieces. \n\n### Response:\n",
    "completion": "(define \"MoveAPiece\" (if (or (= (state at:(from)) 1) (and (= (state at:(from)) 0) (= 1 (pips)))) (move Slide #1 (between (exact (pips)) if:(is Empty (between))) (to if:(\"IsEnemyAt\" (to)) (apply if:(not (\"IsFriendAt\" (to))) (remove (to)))) (then (if (= (state at:(last To)) 0) (set State at:(last To) 1)))))) (game \"Daldos\" (players 2) (equipment { (board (merge { (rectangle 1 16) (shift -1 1 (rectangle 1 17)) (shift 0 2 (rectangle 1 16))}) { (track \"Track1\" {0..15 32..16 33..48 32..16} loop:True P1) (track \"Track2\" {33..48 32..16 0..15 32..16} loop:True P2)} use:Vertex) (regions \"AllSites\" (sites Board)) (dice d:4 num:2) (piece \"Minus\" P1 (\"MoveAPiece\" \"Track1\")) (piece \"Minus\" P2 (\"MoveAPiece\" \"Track2\"))}) (rules (start { (place \"Minus1\" (sites Bottom)) (place \"Minus2\" (sites Top))}) (play (\"RollEachNewTurnMove\" (forEach Die replayDouble:(and (= (face 36) 1) (= (face 37) 1)) (forEach Piece (then (if (not (all DiceUsed)) (\"ReplayIfCanMove\" (forEach Die (forEach Piece))))))))) (end (\"CaptureAll\" Next))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Three-row board, outer rows with sixteen holes and the central with seventeen. Sixteen pieces per player, which start the board in each of the holes in the outer row belonging to a player. Two four-sided dice. Players move their pieces according to the throws of the dice, moving one piece the value of one of the dice and another the value of the other die, or one piece the value of both dice. Players move from their row into the central row, and when reaching the end of the central row, proceed into the opponent's row. Opponent's pieces are taken when a player's piece lands in the same spot as the opponent's piece. Players may not move one of their pieces past one of their other pieces. "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n5x5 board. Players begin by placing their pieces two-by-two in places as they see fit, except for the central space. Once all the spaces except the central one are filled, the player who placed their pieces last moves a piece one space orthogonally to the empty space. Pieces are captured by surrounding them on either side by a player's own pieces. Multiple captures are allowed, and multiple pieces can be captured in a single move. A player may move their piece between two of the opponent's pieces without it resulting in a capture. Pieces in the central spot cannot be captured. If a player cannot move, the opponent must move so that the player can move on their next turn. The player to capture all of the opponent's pieces wins.\n         \n\n### Response:\n",
    "completion": "(define \"Custodial\" (custodial #1 Orthogonal (between (max 1) if:\"EnemyOutsideCentre\" #2) (to if:(\"IsFriendAt\" (to))))) (define \"CaptureAndMoveAgain\" (apply (and (remove (between)) (if \"FlankFromOrthogonalStep\" (moveAgain) (if (no Moves Next) (and (set Pending) (moveAgain))))))) (define \"FlankFromOrthogonalStep\" (or { (can Move (\"Custodial\" (from (ahead (last To) N)))) (can Move (\"Custodial\" (from (ahead (last To) E)))) (can Move (\"Custodial\" (from (ahead (last To) W)))) (can Move (\"Custodial\" (from (ahead (last To) S))))})) (define \"EnemyOutsideCentre\" (and (\"IsEnemyAt\" (between)) (!= (centrePoint) (between)))) (game \"Shantarad\" (players 2) (equipment { (board (square 5)) (hand Each) (piece \"Marker\" Each (\"StepToEmpty\" Orthogonal (then (\"Custodial\" (from (last To)) \"CaptureAndMoveAgain\"))))}) (rules (start (place \"Marker\" \"Hand\" count:12)) phases:{ (phase \"Placement\" (play (if (= (count Moves) 24) (forEach Piece) (move (from (handSite Mover)) (to (difference (sites Empty) (centrePoint))) (then (if (or (= (count Moves) 24) (\"NewTurn\")) (moveAgain)))))) (nextPhase (= (count Moves) 25) \"Movement\")) (phase \"Movement\" (play (if \"SameTurn\" (move Step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or { (and (\"IsEnemyAt\" (ahead (to) W)) (\"IsFriendAt\" (ahead (ahead (to) W) W))) (and (\"IsEnemyAt\" (ahead (to) E)) (\"IsFriendAt\" (ahead (ahead (to) E) E))) (and (\"IsEnemyAt\" (ahead (to) N)) (\"IsFriendAt\" (ahead (ahead (to) N) N))) (and (\"IsEnemyAt\" (ahead (to) S)) (\"IsFriendAt\" (ahead (ahead (to) S) S)))}))) (then (\"Custodial\" (from (last To)) \"CaptureAndMoveAgain\"))) (do (forEach Piece) ifAfterwards:(not (no Moves Next))))))} (end (\"CaptureAll\" Next))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "5x5 board. Players begin by placing their pieces two-by-two in places as they see fit, except for the central space. Once all the spaces except the central one are filled, the player who placed their pieces last moves a piece one space orthogonally to the empty space. Pieces are captured by surrounding them on either side by a player's own pieces. Multiple captures are allowed, and multiple pieces can be captured in a single move. A player may move their piece between two of the opponent's pieces without it resulting in a capture. Pieces in the central spot cannot be captured. If a player cannot move, the opponent must move so that the player can move on their next turn. The player to capture all of the opponent's pieces wins.\n         "
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\n4x5 or 8 board. One counter in each hole.  Players alternate turns picking up the counters in one of their holes and sowing them in an anti-clockwise direction. When the final counter lands in a hole with counters, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opponent's opposite inner row hole are captured, and if this capture was possible, any counters in the outer row hole are also captured. The player who captures all of the opponent's counters wins. Each player has 6 holes per row.\n\n### Response:\n",
    "completion": "(define \"PiecesOwnedBy\" (+ (count Cell at:(handSite #1)) (count in:(sites #1 \"Home\")))) (define \"Columns\" 5) (game \"Nchayo\" (players 2) (equipment { (mancalaBoard 4 \"Columns\" store:None { (track \"Track1\" \"0,E,N1,W\" loop:True P1) (track \"Track2\" \"10,E,N1,W\" loop:True P2)}) (regions \"Home\" P1 (sites Track \"Track1\")) (regions \"Home\" P2 (sites Track \"Track2\")) (regions \"Inner\" P1 (difference (sites Track \"Track1\") (sites Bottom))) (regions \"Inner\" P2 (difference (sites Track \"Track2\") (sites Top))) (piece \"Seed\" Shared) (hand Each)}) (rules (start (set Count 1 to:(sites Board))) (play (move Select (from (if (\"SameTurn\") (\"LastHoleSowed\") (sites Mover \"Home\")) if:(is Occupied (from))) (then (sow \"Track\" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover \"Inner\")) (if (is Occupied (\"OppositePit\" (to))) (and (fromTo (from (\"OppositePit\" (to))) (to (handSite Mover)) count:(count at:(\"OppositePit\" (to)))) (if (is Occupied (\"OppositeOuterPit\" (to))) (fromTo (from (\"OppositeOuterPit\" (to))) (to (handSite Mover)) count:(count at:(\"OppositeOuterPit\" (to))))))))))))) (end (\"MancalaByScoreWhen\" (no Moves Next)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "4x5 or 8 board. One counter in each hole.  Players alternate turns picking up the counters in one of their holes and sowing them in an anti-clockwise direction. When the final counter lands in a hole with counters, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opponent's opposite inner row hole are captured, and if this capture was possible, any counters in the outer row hole are also captured. The player who captures all of the opponent's counters wins. Each player has 6 holes per row."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nDefines a hop move in all the directions specified (by default Adjacent) over an enemy to an empty site. The enemy piece is removed.\n\n### Response:\n",
    "completion": "(define \"HopCapture\" (move Hop #1 #2 (between if:(\"IsEnemyAt\" (between)) (apply (remove (between)))) (to if:(is Empty (to))) #3))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Defines a hop move in all the directions specified (by default Adjacent) over an enemy to an empty site. The enemy piece is removed."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nModify the Ludii game according to the following option changes:\nEach team has 2 scoring sticks. -> Each team has 3 scoring sticks.\n\n### Input:\n(define \"Move\" (if (\"IsEndTrack\" (\"SiteToMoveOnTrack\" from:(from) (\"ThrowValue\"))) (move (from (from)) (to (mapEntry \"Start\" Mover)) (then (fromTo (from (handSite (\"HandOpponent\"))) (to (handSite (\"HandTeam\")))))) (move (from (from)) (to (\"SiteToMoveOnTrack\" from:(from) (\"ThrowValue\")) if:True (apply (if (\"IsEnemyAt\" (to)) (and (fromTo (from (to)) (to (mapEntry \"Start\" (who at:(to))))) (fromTo (from (handSite (\"HandOpponent\"))) (to (handSite (\"HandTeam\")))))))) (then (if (= (last To) (mapEntry \"Opposite\" Mover)) (and (fromTo (from (last To)) (to (mapEntry \"Start\" Mover))) (fromTo (from (handSite (\"HandTeam\"))) (to (handSite (\"HandOpponent\")))))))))) (define \"HandOpponent\" (if (or (is Mover P1) (is Mover P2)) 3 1)) (define \"HandTeam\" (if (or (is Mover P1) (is Mover P2)) 1 3)) (define \"ReplayThrow\" (or (= (\"ThrowValue\") 5) (= (\"ThrowValue\") 10))) (define \"SiteToMoveOnTrack\" (\"NextSiteOnTrack\" #2 #1)) (define \"ThrowValue\" (mapEntry \"Throw\" (count Pips))) (game \"Zohn Ahl\" (players 4) (equipment { (board (graph vertices:{ {0 0} {1 0.4} {2 0.4} {3 0.4} {4 0} {5 0} {6 0.4} {7 0.4} {8 0.4} {9 0} {4 1} {5 1} {-6 3} {-5.6 4} {-5.6 5} {-5.6 6} {-6 7} {-6 8} {-5 7} {-5 8} {-5.6 9} {-5.6 10} {-5.6 11} {-6 12} {0 15} {1 14.6} {2 14.6} {3 14.6} {4 15} {5 15} {6 14.6} {7 14.6} {8 14.6} {9 15} {4 14} {5 14} {15 3} {14.6 4} {14.6 5} {14.6 6} {15 7} {15 8} {14 7} {14 8} {14.6 9} {14.6 10} {14.6 11} {15 12}} edges:{ {0 12} {23 24} {33 47} {36 9} {4 10} {5 11} {16 18} {17 19} {28 34} {35 29} {43 41} {42 40}}) { (track \"Track1\" \"5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End\" P1 directed:True) (track \"Track2\" \"5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End\" P2 directed:True) (track \"Track3\" \"4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End\" P3 directed:True) (track \"Track4\" \"4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End\" P4 directed:True)} use:Vertex) (piece \"Stick\" P1 (\"Move\")) (piece \"Stick\" P3 (\"Move\")) (piece \"Stick\" Neutral) (\"StickDice\" 4) (hand P1) (hand P3) (map \"Throw\" {(pair 0 10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 5)}) (map \"Opposite\" {(pair P1 29) (pair P2 29) (pair P3 28) (pair P4 28)}) (map \"Start\" {(pair P1 5) (pair P2 5) (pair P3 4) (pair P4 4)})}) (rules (start { (set Team 1 {P1 P2}) (set Team 2 {P3 P4}) (place \"Stick1\" 5) (place \"Stick3\" 4) (place \"Stick0\" (handSite P1) count:2) (place \"Stick0\" (handSite P3) count:2)}) (play (\"RollMove\" (if (or (is Mover P1) (is Mover P2)) (forEach Piece P1) (forEach Piece P3)) (then (if (\"ReplayThrow\") (moveAgain))))) (end (if (is Empty (handSite (\"HandOpponent\"))) (result TeamMover Win)))))\n\n### Response:\n",
    "completion": "(define \"Move\" (if (\"IsEndTrack\" (\"SiteToMoveOnTrack\" from:(from) (\"ThrowValue\"))) (move (from (from)) (to (mapEntry \"Start\" Mover)) (then (fromTo (from (handSite (\"HandOpponent\"))) (to (handSite (\"HandTeam\")))))) (move (from (from)) (to (\"SiteToMoveOnTrack\" from:(from) (\"ThrowValue\")) if:True (apply (if (\"IsEnemyAt\" (to)) (and (fromTo (from (to)) (to (mapEntry \"Start\" (who at:(to))))) (fromTo (from (handSite (\"HandOpponent\"))) (to (handSite (\"HandTeam\")))))))) (then (if (= (last To) (mapEntry \"Opposite\" Mover)) (and (fromTo (from (last To)) (to (mapEntry \"Start\" Mover))) (fromTo (from (handSite (\"HandTeam\"))) (to (handSite (\"HandOpponent\")))))))))) (define \"HandOpponent\" (if (or (is Mover P1) (is Mover P2)) 3 1)) (define \"HandTeam\" (if (or (is Mover P1) (is Mover P2)) 1 3)) (define \"ReplayThrow\" (or (= (\"ThrowValue\") 5) (= (\"ThrowValue\") 10))) (define \"SiteToMoveOnTrack\" (\"NextSiteOnTrack\" #2 #1)) (define \"ThrowValue\" (mapEntry \"Throw\" (count Pips))) (game \"Zohn Ahl\" (players 4) (equipment { (board (graph vertices:{ {0 0} {1 0.4} {2 0.4} {3 0.4} {4 0} {5 0} {6 0.4} {7 0.4} {8 0.4} {9 0} {4 1} {5 1} {-6 3} {-5.6 4} {-5.6 5} {-5.6 6} {-6 7} {-6 8} {-5 7} {-5 8} {-5.6 9} {-5.6 10} {-5.6 11} {-6 12} {0 15} {1 14.6} {2 14.6} {3 14.6} {4 15} {5 15} {6 14.6} {7 14.6} {8 14.6} {9 15} {4 14} {5 14} {15 3} {14.6 4} {14.6 5} {14.6 6} {15 7} {15 8} {14 7} {14 8} {14.6 9} {14.6 10} {14.6 11} {15 12}} edges:{ {0 12} {23 24} {33 47} {36 9} {4 10} {5 11} {16 18} {17 19} {28 34} {35 29} {43 41} {42 40}}) { (track \"Track1\" \"5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End\" P1 directed:True) (track \"Track2\" \"5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End\" P2 directed:True) (track \"Track3\" \"4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End\" P3 directed:True) (track \"Track4\" \"4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End\" P4 directed:True)} use:Vertex) (piece \"Stick\" P1 (\"Move\")) (piece \"Stick\" P3 (\"Move\")) (piece \"Stick\" Neutral) (\"StickDice\" 4) (hand P1) (hand P3) (map \"Throw\" {(pair 0 10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 5)}) (map \"Opposite\" {(pair P1 29) (pair P2 29) (pair P3 28) (pair P4 28)}) (map \"Start\" {(pair P1 5) (pair P2 5) (pair P3 4) (pair P4 4)})}) (rules (start { (set Team 1 {P1 P2}) (set Team 2 {P3 P4}) (place \"Stick1\" 5) (place \"Stick3\" 4) (place \"Stick0\" (handSite P1) count:3) (place \"Stick0\" (handSite P3) count:3)}) (play (\"RollMove\" (if (or (is Mover P1) (is Mover P2)) (forEach Piece P1) (forEach Piece P3)) (then (if (\"ReplayThrow\") (moveAgain))))) (end (if (is Empty (handSite (\"HandOpponent\"))) (result TeamMover Win)))))",
    "_var_instruction": "Modify the Ludii game according to the following option changes:\nEach team has 2 scoring sticks. -> Each team has 3 scoring sticks.",
    "_var_input": "(define \"Move\" (if (\"IsEndTrack\" (\"SiteToMoveOnTrack\" from:(from) (\"ThrowValue\"))) (move (from (from)) (to (mapEntry \"Start\" Mover)) (then (fromTo (from (handSite (\"HandOpponent\"))) (to (handSite (\"HandTeam\")))))) (move (from (from)) (to (\"SiteToMoveOnTrack\" from:(from) (\"ThrowValue\")) if:True (apply (if (\"IsEnemyAt\" (to)) (and (fromTo (from (to)) (to (mapEntry \"Start\" (who at:(to))))) (fromTo (from (handSite (\"HandOpponent\"))) (to (handSite (\"HandTeam\")))))))) (then (if (= (last To) (mapEntry \"Opposite\" Mover)) (and (fromTo (from (last To)) (to (mapEntry \"Start\" Mover))) (fromTo (from (handSite (\"HandTeam\"))) (to (handSite (\"HandOpponent\")))))))))) (define \"HandOpponent\" (if (or (is Mover P1) (is Mover P2)) 3 1)) (define \"HandTeam\" (if (or (is Mover P1) (is Mover P2)) 1 3)) (define \"ReplayThrow\" (or (= (\"ThrowValue\") 5) (= (\"ThrowValue\") 10))) (define \"SiteToMoveOnTrack\" (\"NextSiteOnTrack\" #2 #1)) (define \"ThrowValue\" (mapEntry \"Throw\" (count Pips))) (game \"Zohn Ahl\" (players 4) (equipment { (board (graph vertices:{ {0 0} {1 0.4} {2 0.4} {3 0.4} {4 0} {5 0} {6 0.4} {7 0.4} {8 0.4} {9 0} {4 1} {5 1} {-6 3} {-5.6 4} {-5.6 5} {-5.6 6} {-6 7} {-6 8} {-5 7} {-5 8} {-5.6 9} {-5.6 10} {-5.6 11} {-6 12} {0 15} {1 14.6} {2 14.6} {3 14.6} {4 15} {5 15} {6 14.6} {7 14.6} {8 14.6} {9 15} {4 14} {5 14} {15 3} {14.6 4} {14.6 5} {14.6 6} {15 7} {15 8} {14 7} {14 8} {14.6 9} {14.6 10} {14.6 11} {15 12}} edges:{ {0 12} {23 24} {33 47} {36 9} {4 10} {5 11} {16 18} {17 19} {28 34} {35 29} {43 41} {42 40}}) { (track \"Track1\" \"5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End\" P1 directed:True) (track \"Track2\" \"5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End\" P2 directed:True) (track \"Track3\" \"4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End\" P3 directed:True) (track \"Track4\" \"4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End\" P4 directed:True)} use:Vertex) (piece \"Stick\" P1 (\"Move\")) (piece \"Stick\" P3 (\"Move\")) (piece \"Stick\" Neutral) (\"StickDice\" 4) (hand P1) (hand P3) (map \"Throw\" {(pair 0 10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 5)}) (map \"Opposite\" {(pair P1 29) (pair P2 29) (pair P3 28) (pair P4 28)}) (map \"Start\" {(pair P1 5) (pair P2 5) (pair P3 4) (pair P4 4)})}) (rules (start { (set Team 1 {P1 P2}) (set Team 2 {P3 P4}) (place \"Stick1\" 5) (place \"Stick3\" 4) (place \"Stick0\" (handSite P1) count:2) (place \"Stick0\" (handSite P3) count:2)}) (play (\"RollMove\" (if (or (is Mover P1) (is Mover P2)) (forEach Piece P1) (forEach Piece P3)) (then (if (\"ReplayThrow\") (moveAgain))))) (end (if (is Empty (handSite (\"HandOpponent\"))) (result TeamMover Win)))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(game \"Bamboo\" (players 2) (equipment { (board (hex 5)) (piece \"Disc\" Each) (piece \"Disc\" Neutral)}) (rules (play (do (move Add (to (sites Empty))) ifAfterwards:(<= (max (results from:(sites Occupied by:Mover) to:1 (* 1 (size Group at:(from))))) (count Groups if:(= (who at:(to)) (mover)))))) (end (\"NoMoves\" Loss))))\n\n### Response:\n",
    "completion": "Each turn a player places a stone of their color on an empty hex. The placement is subject to the following restriction: After your placement you may not have a group containing more stones than the number of groups you have on the board. The first player unable to place a stone loses the game. A size 5 board is currently selected The standard goal is selected, which means that the first player unable to place loses.",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(game \"Bamboo\" (players 2) (equipment { (board (hex 5)) (piece \"Disc\" Each) (piece \"Disc\" Neutral)}) (rules (play (do (move Add (to (sites Empty))) ifAfterwards:(<= (max (results from:(sites Occupied by:Mover) to:1 (* 1 (size Group at:(from))))) (count Groups if:(= (who at:(to)) (mover)))))) (end (\"NoMoves\" Loss))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a Ludii game based on the following description\n\n### Input:\nPlayers take turns moving a piece of their colour as follows:\n            \n            1. A piece on a vertex can move either:\n            \n            1a. To an adjacent empty vertex. The edge it travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed).\n            \n            1b. To an empty cell that vertex is part of.\n            \n            2. A piece on an edge can move either:\n            \n            2a. To a connected empty edge. The vertex it travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed).\n            \n            2b. To an empty cell that edge is part of.\n            \n            3. A piece in a cell can move either:\n            \n            3a. To a neighbouring empty cell which may be connected by an edge or a vertex. The connecting edge or vertex that the piece travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed).\n            \n            3b. To step over one of its empty edges into an adjacent cell containing an enemy piece (which is captured), then step out over a different empty edge to another empty cell.\n            \n            3c. To an empty vertex or edge belonging to that cell.\n            \n            Aim: A player wins if their opponent is reduced to a single piece. An empty edge has no piece on its midpoint. An empty cell has no piece on its centroid.\n            \n            Three Player Version:\n        In the three player version, any player reduced to a single piece is removed from the game (along with their piece). Last remaining player wins. The game is played with 2 players.\n\n### Response:\n",
    "completion": "(define \"RemoveLastPiece\" (and { (\"RemovePlayerLastPiece\" P1) (\"RemovePlayerLastPiece\" P2) (\"RemovePlayerLastPiece\" P3)})) (define \"RemovePlayerLastPiece\" (if (= 1 (\"CountPiecesAllSiteTypes\" #1)) (and { (\"RemoveSiteTypeOccupiedPiece\" #1 Vertex) (\"RemoveSiteTypeOccupiedPiece\" #1 Cell) (\"RemoveSiteTypeOccupiedPiece\" #1 Edge)}))) (define \"CountPiecesAllSiteTypes\" (+ { (count Pieces Vertex #1) (count Pieces Edge #1) (count Pieces Cell #1)})) (define \"RemoveSiteTypeOccupiedPiece\" (forEach Site (sites Occupied by:#1 container:\"Board\" on:#2) (remove #2 (site)))) (define \"MoveCellToVertex\" (move (from Cell) (to Vertex (intersection (sites Empty Vertex) (sites Incident Vertex of:Cell at:(from)))))) (define \"MoveCellToEdge\" (move (from Cell) (to Edge (intersection (sites Empty Edge) (sites Incident Edge of:Cell at:(from)))))) (define \"MoveCellToEmptyCellOverVertex\" (move (from Cell) (to Cell (forEach (sites Empty Cell) if:(= 1 (count Sites in:(intersection (sites Incident Vertex of:Cell at:(from)) (sites Incident Vertex of:Cell at:(site))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who Vertex at:(site))) (remove Vertex (site))))))) (define \"MoveCellToEnemyCellOverEmptyEdge\" (move (from Cell) (to Cell (sites Incident Cell of:Cell at:(from)) if:(and (is Enemy (who Cell at:(to))) (= 1 (count Sites in:(intersection { (sites Empty Edge) (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))})))) (apply (remove Cell (to)))) (then (moveAgain)))) (define \"MoveCellToEmptyCellOverEdge\" (move (from Cell) (to Cell (intersection (sites Empty Cell) (sites Incident Cell of:Cell at:(from)))) (then (forEach Site (intersection (sites Incident Edge of:Cell at:(last From)) (sites Incident Edge of:Cell at:(last To))) (if (is Enemy (who Edge at:(site))) (remove Edge (site))))))) (define \"MoveEdgetoCell\" (move (from Edge) (to Cell (intersection (sites Empty Cell) (sites Incident Cell of:Edge at:(from)))))) (define \"MoveEdgetoEdge\" (move Step (from Edge) (to if:(is Empty Edge (to))) (then (forEach Site (intersection (sites Incident Vertex of:Edge at:(last From)) (sites Incident Vertex of:Edge at:(last To))) (if (is Enemy (who Vertex at:(site))) (remove Vertex (site))))))) (define \"MoveLastCellToEmptyCellOverEmptyEdge\" (move (from Cell (last To)) (to Cell (intersection (sites Empty Cell) (sites Incident Cell of:Cell at:(from))) if:(and (= 1 (count Sites in:(intersection { (sites Empty Edge) (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))}))) (!= (last From) (to)))))) (define \"MoveVertexToCell\" (move (from Vertex) (to Cell (intersection (sites Empty Cell) (sites Incident Cell of:Vertex at:(from)))))) (define \"MoveVertexToVertex\" (move Step (from Vertex) (to if:(is Empty Vertex (to))) (then (forEach Site (intersection (sites Incident Edge of:Vertex at:(last From)) (sites Incident Edge of:Vertex at:(last To))) (if (is Enemy (who Edge at:(site))) (remove Edge (site))))))) (game \"Triple Tangle\" (players 2) (equipment { (board (tiling T3464 1) use:Vertex) (piece \"Disc\" Each)}) (rules (start { (place \"Disc1\" (sites {4 5 0 1})) (place \"Disc1\" Cell 1) (place \"Disc1\" Edge (sites {0 3 4 9})) (place \"Disc2\" (sites {16 17 12 13})) (place \"Disc2\" Cell 11) (place \"Disc2\" Edge (sites {25 29 26 20}))}) (play (if (\"SameTurn\") (\"MoveLastCellToEmptyCellOverEmptyEdge\") (or { (forEach Piece on:Vertex (or (\"MoveVertexToVertex\") (\"MoveVertexToCell\"))) (forEach Piece on:Edge (or (\"MoveEdgetoEdge\") (\"MoveEdgetoCell\"))) (forEach Piece on:Cell (or { (\"MoveCellToEmptyCellOverEdge\") (\"MoveCellToEnemyCellOverEmptyEdge\") (\"MoveCellToEmptyCellOverVertex\") (\"MoveCellToEdge\") (\"MoveCellToVertex\")}))}))) (end (if (>= 1 (\"CountPiecesAllSiteTypes\" Next)) (result Mover Win)))))",
    "_var_instruction": "Construct a Ludii game based on the following description",
    "_var_input": "Players take turns moving a piece of their colour as follows:\n            \n            1. A piece on a vertex can move either:\n            \n            1a. To an adjacent empty vertex. The edge it travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed).\n            \n            1b. To an empty cell that vertex is part of.\n            \n            2. A piece on an edge can move either:\n            \n            2a. To a connected empty edge. The vertex it travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed).\n            \n            2b. To an empty cell that edge is part of.\n            \n            3. A piece in a cell can move either:\n            \n            3a. To a neighbouring empty cell which may be connected by an edge or a vertex. The connecting edge or vertex that the piece travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed).\n            \n            3b. To step over one of its empty edges into an adjacent cell containing an enemy piece (which is captured), then step out over a different empty edge to another empty cell.\n            \n            3c. To an empty vertex or edge belonging to that cell.\n            \n            Aim: A player wins if their opponent is reduced to a single piece. An empty edge has no piece on its midpoint. An empty cell has no piece on its centroid.\n            \n            Three Player Version:\n        In the three player version, any player reduced to a single piece is removed from the game (along with their piece). Last remaining player wins. The game is played with 2 players."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(define \"HaveAPieceAndCanEscape\" (and (\"IsFriendAt\" (site)) (< (trackSite Move from:(site) steps:(pips)) 0))) (define \"SetScoreOf\" (score #1 (if (is Mover #1) (if (= (\"NumPiece\" #2) 15) 2 1) 0))) (define \"NotEmptyAndNotOffTheBoard\" (and (is Occupied (site)) (\"IsNotOffBoard\" (\"NextSiteFrom\" (site))))) (define \"CanEscape\" (\"IsEndTrack\" (\"NextSiteFrom\" (site)))) (define \"NumPiece\" (size Stack in:(sites Occupied by:#1))) (define \"AllPieceEscaped\" (no Pieces Mover)) (define \"MoveAPieceIf\" (forEach Die replayDouble:True if:#1 (\"MoveAPiece\" #2))) (define \"MoveAPiece\" (move (from #1) (to (\"NextSiteFrom\" #1) if:(\"NoEnemyOrOnlyOne\" (to)) (\"HittingCapture\" (mapEntry Next))))) (define \"DieNotUsedAndNoEscapeAndNotOffTheTrack\" (and { (\"DieNotUsed\") (\"IsNotOffBoard\" (\"NextSiteFrom\" (from))) (\"IsNotEndTrack\" (\"NextSiteFrom\" (from)))})) (define \"RemoveAPiece\" (move Remove (site))) (define \"AllPieceInHome\" (\"AllOwnedPiecesIn\" (sites Mover))) (define \"Bar\" (mapEntry (mover))) (define \"NextSiteFrom\" (\"NextSiteOnTrack\" (pips) from:#1)) (define \"BarEmpty\" (is Empty \"Bar\")) (game \"Portes\" (players 2) (equipment { (\"BackgammonBoard\" (\"BackgammonTracksWithBar\" End)) (dice num:2) (regions P1 { 20..25}) (regions P2 { 7..12}) (map {(pair 1 6) (pair 2 19)}) (piece \"Disc\" Each (\"MoveAPieceIf\" \"DieNotUsedAndNoEscapeAndNotOffTheTrack\" (from)))}) (rules (start { (place Stack \"Disc1\" 0 count:5) (place Stack \"Disc1\" 12 count:2) (place Stack \"Disc1\" 17 count:3) (place Stack \"Disc1\" 20 count:5) (place Stack \"Disc2\" 4 count:3) (place Stack \"Disc2\" 7 count:5) (place Stack \"Disc2\" 13 count:5) (place Stack \"Disc2\" 25 count:2)}) (play (\"RollEachNewTurnMove\" (if \"AllPieceInHome\" (forEach Die replayDouble:True if:(\"DieNotUsed\") (forEach Site (sites Occupied by:Mover) (if (\"NotEmptyAndNotOffTheBoard\") (if (\"CanEscape\") (\"RemoveAPiece\") (\"MoveAPiece\" (site)))) noMoveYet:(firstMoveOnTrack \"Track\" Mover (if \"HaveAPieceAndCanEscape\" \"RemoveAPiece\")) (then (\"ReplayNotAllDiceUsed\")))) (max Distance \"Track\" Mover (if \"BarEmpty\" (forEach Piece top:True) (\"MoveAPieceIf\" (\"DieNotUsed\") (\"Bar\")) (then (if (not (all DiceUsed)) (if (can Move (if \"BarEmpty\" (forEach Piece top:True) (\"MoveAPieceIf\" (\"DieNotUsed\") (\"Bar\")))) (moveAgain))))))))) (end (if (\"AllPieceEscaped\") (byScore { (\"SetScoreOf\" P1 P2) (\"SetScoreOf\" P2 P1)})))))\n\n### Response:\n",
    "completion": "The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Play begins by each player rolling one die; the player who rolls the highest plays first, and then rolls again to begin play. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. The winner gains one point, or two points if the opponent has pieces in their starting quadrant.\n             ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(define \"HaveAPieceAndCanEscape\" (and (\"IsFriendAt\" (site)) (< (trackSite Move from:(site) steps:(pips)) 0))) (define \"SetScoreOf\" (score #1 (if (is Mover #1) (if (= (\"NumPiece\" #2) 15) 2 1) 0))) (define \"NotEmptyAndNotOffTheBoard\" (and (is Occupied (site)) (\"IsNotOffBoard\" (\"NextSiteFrom\" (site))))) (define \"CanEscape\" (\"IsEndTrack\" (\"NextSiteFrom\" (site)))) (define \"NumPiece\" (size Stack in:(sites Occupied by:#1))) (define \"AllPieceEscaped\" (no Pieces Mover)) (define \"MoveAPieceIf\" (forEach Die replayDouble:True if:#1 (\"MoveAPiece\" #2))) (define \"MoveAPiece\" (move (from #1) (to (\"NextSiteFrom\" #1) if:(\"NoEnemyOrOnlyOne\" (to)) (\"HittingCapture\" (mapEntry Next))))) (define \"DieNotUsedAndNoEscapeAndNotOffTheTrack\" (and { (\"DieNotUsed\") (\"IsNotOffBoard\" (\"NextSiteFrom\" (from))) (\"IsNotEndTrack\" (\"NextSiteFrom\" (from)))})) (define \"RemoveAPiece\" (move Remove (site))) (define \"AllPieceInHome\" (\"AllOwnedPiecesIn\" (sites Mover))) (define \"Bar\" (mapEntry (mover))) (define \"NextSiteFrom\" (\"NextSiteOnTrack\" (pips) from:#1)) (define \"BarEmpty\" (is Empty \"Bar\")) (game \"Portes\" (players 2) (equipment { (\"BackgammonBoard\" (\"BackgammonTracksWithBar\" End)) (dice num:2) (regions P1 { 20..25}) (regions P2 { 7..12}) (map {(pair 1 6) (pair 2 19)}) (piece \"Disc\" Each (\"MoveAPieceIf\" \"DieNotUsedAndNoEscapeAndNotOffTheTrack\" (from)))}) (rules (start { (place Stack \"Disc1\" 0 count:5) (place Stack \"Disc1\" 12 count:2) (place Stack \"Disc1\" 17 count:3) (place Stack \"Disc1\" 20 count:5) (place Stack \"Disc2\" 4 count:3) (place Stack \"Disc2\" 7 count:5) (place Stack \"Disc2\" 13 count:5) (place Stack \"Disc2\" 25 count:2)}) (play (\"RollEachNewTurnMove\" (if \"AllPieceInHome\" (forEach Die replayDouble:True if:(\"DieNotUsed\") (forEach Site (sites Occupied by:Mover) (if (\"NotEmptyAndNotOffTheBoard\") (if (\"CanEscape\") (\"RemoveAPiece\") (\"MoveAPiece\" (site)))) noMoveYet:(firstMoveOnTrack \"Track\" Mover (if \"HaveAPieceAndCanEscape\" \"RemoveAPiece\")) (then (\"ReplayNotAllDiceUsed\")))) (max Distance \"Track\" Mover (if \"BarEmpty\" (forEach Piece top:True) (\"MoveAPieceIf\" (\"DieNotUsed\") (\"Bar\")) (then (if (not (all DiceUsed)) (if (can Move (if \"BarEmpty\" (forEach Piece top:True) (\"MoveAPieceIf\" (\"DieNotUsed\") (\"Bar\")))) (moveAgain))))))))) (end (if (\"AllPieceEscaped\") (byScore { (\"SetScoreOf\" P1 P2) (\"SetScoreOf\" P2 P1)})))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nChecks if the next player has no legal moves and the next player loses and checks if a specific player has less or equal than a number of pieces to lose. This ludemeplex can be used only in an ending condition.\n\n### Response:\n",
    "completion": "(define \"NoMovesLossAndLessNumPiecesPlayerLoss\" { (\"NoMoves\" Loss) (if (<= (count Pieces #1) #2) (result #1 Loss))})",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Checks if the next player has no legal moves and the next player loses and checks if a specific player has less or equal than a number of pieces to lose. This ludemeplex can be used only in an ending condition."
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nDescribe the mechanics of the following Ludii game\n\n### Input:\n(define \"Score\" (+ (results from:(intersection (sites Occupied by:#1) (sites Around (sites Occupied by:Neutral) Orthogonal)) to:1 (* (to) (size Group at:(+ (results from:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Neutral)) to:1 (* (from) (to)))) Orthogonal if:(= (id \"Disc0\") (what at:(to)))))))) (game \"Flower Shop\" (players 2) (equipment { (board (hex 7)) (tile \"Hex\" Each) (piece \"Disc\" Neutral)}) (rules (play (do (or (move Add (piece (mover)) (to (sites Empty) if:(= 0 (count Sites in:(intersection (sites Occupied by:All component:\"Hex\") (sites Around (to) Orthogonal)))))) (move Add (piece \"Disc0\") (to (sites Empty)))) ifAfterwards:(and (all Sites (sites Occupied by:All component:\"Hex\") if:(> 2 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:Neutral))))) (all Sites (sites Occupied by:Neutral) if:(not (and (< 0 (count Sites in:(sites Around (sites Group at:(site)) Own Orthogonal))) (< 0 (count Sites in:(sites Around (sites Group at:(site)) Enemy Orthogonal))))))) (then (if (= 1 (% (+ 1 (count Moves)) 2)) (moveAgain))))) (end (if (all Passed) (byScore { (score P1 (\"Score\" P1)) (score P2 (\"Score\" P2))})))))\n\n### Response:\n",
    "completion": "Flower Shop is played on a hexhex board and uses the 12* placement protocol, that is: barring the first player's first placement, which must be a single piece, players make two placements in a turn. There are two types of pieces: impartial *stalks* (green) and partial *flowers* (pink and yellow). A maximal set of connected stalks is called a *plant*.\n            \n            Rules\n            There are two placement restrictions:\n            1. Each flower may be adjacent to no more than one stalk and no other flowers.\n            2. Each plant can only be adjacent to at most one colour of flowers.\n            \n            The game ends when no legal placements can be made. The *worth* of each plant is the number of stalks in it times the number of flowers adjacent to it. The *score* of each player is the total worth of all the plants adjacent to his flowers. Highest score wins. In case of equal scores, no player wins.\n            \n        (Description taken - but slightly adapted - from mindsports.nl.) ",
    "_var_instruction": "Describe the mechanics of the following Ludii game",
    "_var_input": "(define \"Score\" (+ (results from:(intersection (sites Occupied by:#1) (sites Around (sites Occupied by:Neutral) Orthogonal)) to:1 (* (to) (size Group at:(+ (results from:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Neutral)) to:1 (* (from) (to)))) Orthogonal if:(= (id \"Disc0\") (what at:(to)))))))) (game \"Flower Shop\" (players 2) (equipment { (board (hex 7)) (tile \"Hex\" Each) (piece \"Disc\" Neutral)}) (rules (play (do (or (move Add (piece (mover)) (to (sites Empty) if:(= 0 (count Sites in:(intersection (sites Occupied by:All component:\"Hex\") (sites Around (to) Orthogonal)))))) (move Add (piece \"Disc0\") (to (sites Empty)))) ifAfterwards:(and (all Sites (sites Occupied by:All component:\"Hex\") if:(> 2 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:Neutral))))) (all Sites (sites Occupied by:Neutral) if:(not (and (< 0 (count Sites in:(sites Around (sites Group at:(site)) Own Orthogonal))) (< 0 (count Sites in:(sites Around (sites Group at:(site)) Enemy Orthogonal))))))) (then (if (= 1 (% (+ 1 (count Moves)) 2)) (moveAgain))))) (end (if (all Passed) (byScore { (score P1 (\"Score\" P1)) (score P2 (\"Score\" P2))})))))"
  },
  {
    "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nConstruct a global Ludii definition which fulfills the following requirements.\n\n### Input:\nReturns a region of one site corresponding to the last `to' position after applying the consequences. In the mancala games, this site is the last hole in which a seed was sowed. \n\n### Response:\n",
    "completion": "(define \"LastHoleSowed\" (sites {(last To afterConsequence:True)}))",
    "_var_instruction": "Construct a global Ludii definition which fulfills the following requirements.",
    "_var_input": "Returns a region of one site corresponding to the last `to' position after applying the consequences. In the mancala games, this site is the last hole in which a seed was sowed. "
  }
]